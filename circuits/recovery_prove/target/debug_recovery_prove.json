{"debug_symbols":[{"locations":{"192":[{"span":{"start":205,"end":234},"file":0}],"193":[{"span":{"start":247,"end":269},"file":0}],"194":[{"span":{"start":247,"end":269},"file":0}],"195":[{"span":{"start":247,"end":269},"file":0}],"196":[{"span":{"start":247,"end":269},"file":0}],"197":[{"span":{"start":247,"end":269},"file":0}],"198":[{"span":{"start":247,"end":269},"file":0}],"199":[{"span":{"start":247,"end":269},"file":0}],"200":[{"span":{"start":247,"end":269},"file":0}],"201":[{"span":{"start":247,"end":269},"file":0}],"202":[{"span":{"start":247,"end":269},"file":0}],"203":[{"span":{"start":247,"end":269},"file":0}],"204":[{"span":{"start":247,"end":269},"file":0}],"205":[{"span":{"start":247,"end":269},"file":0}],"206":[{"span":{"start":247,"end":269},"file":0}],"207":[{"span":{"start":247,"end":269},"file":0}],"208":[{"span":{"start":247,"end":269},"file":0}],"209":[{"span":{"start":247,"end":269},"file":0}],"210":[{"span":{"start":247,"end":269},"file":0}],"211":[{"span":{"start":247,"end":269},"file":0}],"212":[{"span":{"start":247,"end":269},"file":0}],"213":[{"span":{"start":247,"end":269},"file":0}],"214":[{"span":{"start":247,"end":269},"file":0}],"215":[{"span":{"start":247,"end":269},"file":0}],"216":[{"span":{"start":247,"end":269},"file":0}],"217":[{"span":{"start":247,"end":269},"file":0}],"218":[{"span":{"start":247,"end":269},"file":0}],"219":[{"span":{"start":247,"end":269},"file":0}],"220":[{"span":{"start":247,"end":269},"file":0}],"221":[{"span":{"start":247,"end":269},"file":0}],"222":[{"span":{"start":247,"end":269},"file":0}],"223":[{"span":{"start":247,"end":269},"file":0}],"224":[{"span":{"start":247,"end":269},"file":0}],"225":[{"span":{"start":367,"end":408},"file":0},{"span":{"start":1124,"end":1213},"file":2}],"226":[{"span":{"start":422,"end":438},"file":0}]}}],"file_map":{"0":{"source":"use dep::std;\nuse dep::ecrecover;\n\nfn main(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64],\n    hashed_message: pub [u8; 32],\n    pub_key_x_hash: pub [u8; 32]\n) {\n    let hash = std::hash::blake2s(pub_key_x);\n    assert(hash == pub_key_x_hash);\n\n    let key = ecrecover::secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n    let is_valid = key.verify_sig(signature, hashed_message);\n\n    assert(is_valid == true);\n}\n\n#[test]\nfn test_main() {\n    let pub_key_x:[u8;32] = [\n        170, 60, 143, 56, 248, 157, 141, 21, 50, 59, 118, 206, 25, 184, 193, 178, 24, 94, 134, 182, 23, 75, 190, 175, 196, 0, 115, 207, 219, 41, 80, 7\n    ];\n\n    let pub_key_y:[u8;32] = [\n        236, 173, 206, 117, 192, 95, 205, 216, 12, 197, 238, 54, 32, 74, 217, 37, 58, 46, 91, 93, 224, 94, 136, 170, 203, 64, 182, 58, 67, 142, 66, 166\n    ];\n\n    let signature:[u8;64] = [\n        204, 97, 78, 27, 238, 142, 35, 219, 48, 246, 255, 157, 128, 194, 165, 49, 212, 186, 243, 145, 118, 239, 112, 28, 222, 214, 25, 99, 114, 229, 127, 148, 36, 49, 90, 42, 81, 34, 171, 149, 27, 78, 126, 97, 249, 201, 122, 177, 162, 17, 162, 138, 36, 155, 207, 114, 181, 15, 73, 86, 241, 150, 169, 104\n    ];\n\n    let hashed_message:[u8;32] = [\n        161, 222, 152, 134, 0, 164, 44, 75, 74, 176, 137, 182, 25, 41, 124, 23, 213, 60, 255, 174, 93, 81, 32, 216, 45, 138, 146, 208, 187, 59, 120, 242\n    ];\n\n    let pub_key_x_hash:[u8;32] = [\n        0x000000000000000000000000000000000000000000000000000000000000002d, 0x0000000000000000000000000000000000000000000000000000000000000074, 0x00000000000000000000000000000000000000000000000000000000000000a9, 0x0000000000000000000000000000000000000000000000000000000000000091, 0x00000000000000000000000000000000000000000000000000000000000000e0, 0x00000000000000000000000000000000000000000000000000000000000000b7, 0x0000000000000000000000000000000000000000000000000000000000000057, 0x00000000000000000000000000000000000000000000000000000000000000cc, 0x0000000000000000000000000000000000000000000000000000000000000088, 0x000000000000000000000000000000000000000000000000000000000000008e, 0x0000000000000000000000000000000000000000000000000000000000000003, 0x000000000000000000000000000000000000000000000000000000000000006f, 0x0000000000000000000000000000000000000000000000000000000000000060, 0x000000000000000000000000000000000000000000000000000000000000009e, 0x000000000000000000000000000000000000000000000000000000000000006a, 0x0000000000000000000000000000000000000000000000000000000000000097, 0x000000000000000000000000000000000000000000000000000000000000009f, 0x00000000000000000000000000000000000000000000000000000000000000ec, 0x0000000000000000000000000000000000000000000000000000000000000055, 0x00000000000000000000000000000000000000000000000000000000000000e8, 0x0000000000000000000000000000000000000000000000000000000000000073, 0x0000000000000000000000000000000000000000000000000000000000000060, 0x00000000000000000000000000000000000000000000000000000000000000aa, 0x0000000000000000000000000000000000000000000000000000000000000083, 0x00000000000000000000000000000000000000000000000000000000000000f9, 0x0000000000000000000000000000000000000000000000000000000000000098, 0x0000000000000000000000000000000000000000000000000000000000000023, 0x00000000000000000000000000000000000000000000000000000000000000af, 0x0000000000000000000000000000000000000000000000000000000000000011, 0x0000000000000000000000000000000000000000000000000000000000000054, 0x0000000000000000000000000000000000000000000000000000000000000076, 0x0000000000000000000000000000000000000000000000000000000000000064\n    ];\n\n    main(pub_key_x, pub_key_y, signature, hashed_message, pub_key_x_hash);\n}\n","path":"/Users/anoy/Documents/Hackathon Projects/CelestialWallet/circuits/recovery_prove/src/main.nr"},"2":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/anoy/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"}},"warnings":[]}