{
  "address": "0x88a0b5C0AACBF567400B29632aA90b81e9a2f01f",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_trustedForwarder",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_passkeyVerifier",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_recoveryVerifier",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CELESTIAL_IMPLEMENTATION",
      "outputs": [
        {
          "internalType": "contract Celestial",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "name": "CelestialNameToDetails",
      "outputs": [
        {
          "internalType": "address",
          "name": "walletAddress",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "isUsed",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes32",
          "name": "passwordHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "recoveryHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "salt",
          "type": "uint256"
        }
      ],
      "name": "createAccount",
      "outputs": [
        {
          "internalType": "contract Celestial",
          "name": "ret",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        },
        {
          "internalType": "address[]",
          "name": "dests",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "values",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes[]",
          "name": "funcs",
          "type": "bytes[]"
        }
      ],
      "name": "executeCelestialBatchTx",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "_recoveryHash",
          "type": "bytes32"
        }
      ],
      "name": "executeCelestialChangeRecovery",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "_passwordHash",
          "type": "bytes32"
        }
      ],
      "name": "executeCelestialPasskeyRecovery",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "bytes",
          "name": "proof",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "dest",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "func",
          "type": "bytes"
        }
      ],
      "name": "executeCelestialTx",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "passwordHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "recoveryHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "salt",
          "type": "uint256"
        }
      ],
      "name": "getAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        }
      ],
      "name": "getCelestial",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "walletAddress",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "isUsed",
              "type": "bool"
            }
          ],
          "internalType": "struct CelestialStorage.CelestialDetails",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "forwarder",
          "type": "address"
        }
      ],
      "name": "isTrustedForwarder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x5501ba3404bc5c67a1800b81348bcf67bd378617ac8cb28514f1ebbfa97b5102",
  "receipt": {
    "to": null,
    "from": "0xDb1d125C9f7faE45d7CeE470d048670a85270f4D",
    "contractAddress": "0x88a0b5C0AACBF567400B29632aA90b81e9a2f01f",
    "transactionIndex": 0,
    "gasUsed": "2599956",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x690ad8edeec05b0b7d40d85e46998223361c727dd208fa324da1256f5807332f",
    "transactionHash": "0x5501ba3404bc5c67a1800b81348bcf67bd378617ac8cb28514f1ebbfa97b5102",
    "logs": [],
    "blockNumber": 65764845,
    "cumulativeGasUsed": "2599956",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xcbd8ef2d15e11fc65793e693d7d11e918fafa5d6",
    "0x50f1bbb486d62921ed9ce411c6b85ec0b73d9130",
    "0xf1e842ef0774dbe7caf7f0f95d1315fd834d2a4b"
  ],
  "numDeployments": 2,
  "solcInputHash": "7ee10287debc3e6ceb5592f9f8a2608c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedForwarder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_passkeyVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recoveryVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CELESTIAL_IMPLEMENTATION\",\"outputs\":[{\"internalType\":\"contract Celestial\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"CelestialNameToDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUsed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"passwordHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"contract Celestial\",\"name\":\"ret\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"dests\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"funcs\",\"type\":\"bytes[]\"}],\"name\":\"executeCelestialBatchTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_recoveryHash\",\"type\":\"bytes32\"}],\"name\":\"executeCelestialChangeRecovery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_passwordHash\",\"type\":\"bytes32\"}],\"name\":\"executeCelestialPasskeyRecovery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"func\",\"type\":\"bytes\"}],\"name\":\"executeCelestialTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"passwordHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recoveryHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"getCelestial\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isUsed\",\"type\":\"bool\"}],\"internalType\":\"struct CelestialStorage.CelestialDetails\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/CelestialFactory.sol\":\"CelestialFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC1967.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0x3cbef5ebc24b415252e2f8c0c9254555d30d9f085603b4b80d9b5ed20ab87e90\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"@openzeppelin/contracts/metatx/ERC2771Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (metatx/ERC2771Context.sol)\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\nabstract contract ERC2771Context is Context {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\n    address private immutable _trustedForwarder;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor(address trustedForwarder) {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual override returns (address sender) {\\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return super._msgSender();\\n        }\\n    }\\n\\n    function _msgData() internal view virtual override returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return super._msgData();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5e8c266715f6454b732e6c12a85f75dcf3b1c298a90830bb56bfda29fa5b6264\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xa2b22da3032e50b55f95ec1d13336102d675f341167aa76db571ef7f8bb7975d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/IERC1967.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967Upgrade is IERC1967 {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3b21ae06bf5957f73fa16754b0669c77b7abd8ba6c072d35c3281d446fdb86c2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x3d6069be9b4c01fb81840fb9c2c4dc58dd6a6a4aafaa2c6837de8699574d84c6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xeb373f1fdc7b755c6a750123a9b9e3a8a02c1470042fd6505d875000a80bde0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\\n *\\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\\n * contract implement this interface (contract holders can be their own\\n * implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777Recipient {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever tokens are being\\n     * moved or created into a registered account (`to`). The type of operation\\n     * is conveyed by `from` being the zero address or not.\\n     *\\n     * This call occurs _after_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1a5d61db2733202ba361e6d6741cd2e662380e22b80e987eacfc91973f2267dc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Create2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x6e00f269073ffc4350e56b7e8153c9092d5f70bfba423299990514183101ef89\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf09e68aa0dc6722a25bc46490e8d48ed864466d17313b8a0b254c36b54e49899\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/Celestial.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./callback/TokenCallbackHandler.sol\\\";\\nimport \\\"@openzeppelin/contracts/metatx/ERC2771Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nimport \\\"./verifier/PasskeyVerifier.sol\\\";\\nimport \\\"./verifier/RecoveryVerifier.sol\\\";\\n\\nimport \\\"./utils/Conversion.sol\\\";\\n\\ncontract Celestial is TokenCallbackHandler, Initializable{\\n    address public immutable CELESTIAL_FACTORY;\\n    PasskeyUltraVerifier public immutable PASSKEY_VERIFIER;\\n    RecoveryUltraVerifier public immutable RECOVERY_VERIFIER;\\n\\n    bytes32 public passwordHash;\\n\\n    bytes32 public recoveryHash;\\n\\n    uint256 private nonce;\\n\\n    constructor(\\n        address _celestialFactory,\\n        address _passkeyVerifier,\\n        address _recoveryVerifier\\n    ) {\\n        CELESTIAL_FACTORY = _celestialFactory;\\n        PASSKEY_VERIFIER = PasskeyUltraVerifier(_passkeyVerifier);\\n        RECOVERY_VERIFIER = RecoveryUltraVerifier(_recoveryVerifier);\\n    }\\n\\n    modifier onlyCelestialFactory() {\\n        require(msg.sender == CELESTIAL_FACTORY, \\\"Celestial: Only Celestial Factory\\\");\\n        _;\\n    }\\n\\n    function getNonce() public view returns (uint256) {\\n        return nonce;\\n    }\\n\\n    function _useNonce() internal returns (uint256) {\\n        unchecked {\\n            return nonce++;\\n        }\\n    }\\n\\n    function initialize(bytes32 _passwordHash, bytes32 _recoveryHash) external initializer {\\n        _initialize(_passwordHash, _recoveryHash);\\n    }\\n\\n    function _initialize(bytes32 _passwordHash, bytes32 _recoveryHash) internal virtual {\\n        passwordHash = _passwordHash;\\n        recoveryHash = _recoveryHash;\\n    }\\n\\n    function verifyPasskey(bytes calldata proof) public view returns (bool) {\\n        bytes32[] memory byte32Inputs = new bytes32[](2);\\n\\n        byte32Inputs[0] = passwordHash;\\n        byte32Inputs[1] = bytes32(getNonce());\\n\\n        return PASSKEY_VERIFIER.verify(proof, byte32Inputs);\\n    }\\n\\n    function verifyRecovery(bytes calldata proof) public view returns (bool) {\\n        bytes32 message = Conversion.hashMessage(Strings.toString(getNonce()));\\n\\n        bytes32[] memory _inputs = Conversion.convertInputs(message, recoveryHash);\\n\\n        return RECOVERY_VERIFIER.verify(proof, _inputs);\\n    }\\n\\n    function usePasskey(bytes calldata proof) internal returns (bool) {\\n        bytes32[] memory byte32Inputs = new bytes32[](2);\\n\\n        byte32Inputs[0] = passwordHash;\\n        byte32Inputs[1] = bytes32(_useNonce());\\n\\n        return PASSKEY_VERIFIER.verify(proof, byte32Inputs);\\n    }\\n\\n    function useRecovery(bytes calldata proof) internal returns (bool) {\\n        bytes32 message = Conversion.hashMessage(Strings.toString(_useNonce()));\\n\\n        bytes32[] memory _inputs = Conversion.convertInputs(message, recoveryHash);\\n\\n        return RECOVERY_VERIFIER.verify(proof, _inputs);\\n    }\\n\\n    function execute(bytes calldata proof, address dest, uint256 value, bytes calldata func) external payable returns (bool) {\\n        require(usePasskey(proof), \\\"Invalid passkey\\\");\\n        _execute(dest, value, func);\\n        return true;\\n    }\\n\\n    function executeBatch(bytes calldata proof, address[] calldata dest, uint256[] calldata value, bytes[] calldata func) external payable returns (bool) {\\n        require(usePasskey(proof), \\\"Invalid passkey\\\");\\n        _executeBatch(dest, value, func);\\n        return true;\\n    }\\n\\n    function executePasskeyRecovery(bytes calldata proof, bytes32 _passwordHash) external payable returns (bool) {\\n        require(useRecovery(proof), \\\"Invalid recovery\\\");\\n        _changePassword(_passwordHash);\\n        return true;\\n    }\\n\\n    function executeChangeRecovery(bytes calldata proof, bytes32 _recoveryHash) external payable returns (bool) {\\n        require(useRecovery(proof), \\\"Invalid recovery\\\");\\n        _changeRecovery(_recoveryHash);\\n        return true;\\n    }\\n\\n    function _changePassword(bytes32 _passwordHash) internal  {\\n\\t\\tpasswordHash = _passwordHash;\\n\\t}\\n\\n    function _changeRecovery(bytes32 _recoveryHash) internal  {\\n        recoveryHash = _recoveryHash;\\n    }\\n\\n    function _execute(address dest, uint256 value, bytes calldata func) internal {\\n        _call(dest, value, func);\\n    }\\n\\n    function _executeBatch(address[] calldata dest, uint256[] calldata value, bytes[] calldata func) internal {\\n        require(dest.length == func.length && (value.length == 0 || value.length == func.length), \\\"wrong array lengths\\\");\\n        if (value.length == 0) {\\n            for (uint256 i = 0; i < dest.length; i++) {\\n                _call(dest[i], 0, func[i]);\\n            }\\n        } else {\\n            for (uint256 i = 0; i < dest.length; i++) {\\n                _call(dest[i], value[i], func[i]);\\n            }\\n        }\\n    }\\n\\n\\tfunction _call(address target, uint256 value, bytes memory data) internal {\\n        (bool success, bytes memory result) = target.call{value : value}(data);\\n        if (!success) {\\n            assembly {\\n                revert(add(result, 32), mload(result))\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    fallback() external payable {}\\n}\",\"keccak256\":\"0xa669beaedee291eadf19174b9c6e7217389ca5d3d38b6539669bf84cfce26fb0\",\"license\":\"MIT\"},\"contracts/CelestialFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./Celestial.sol\\\";\\nimport \\\"./CelestialStorage.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/metatx/ERC2771Context.sol\\\";\\n\\ncontract CelestialFactory is CelestialStorage, ERC2771Context {\\n    Celestial public immutable CELESTIAL_IMPLEMENTATION;\\n\\n    constructor(address _trustedForwarder, address _passkeyVerifier, address _recoveryVerifier) ERC2771Context(_trustedForwarder) {\\n        CELESTIAL_IMPLEMENTATION = new Celestial(address(this), _passkeyVerifier, _recoveryVerifier);\\n    }\\n\\n    modifier onlyTrustedForwarder() {\\n        require(isTrustedForwarder(msg.sender), \\\"VUZI: caller is not the trusted forwarder\\\");\\n        _;\\n    }\\n\\n    function createAccount(string memory name, bytes32 passwordHash, bytes32 recoveryHash, uint256 salt) external returns (Celestial ret) {\\n        require(CelestialNameToDetails[name].isUsed == false, \\\"Celestial: Celestial already exists\\\");\\n\\n        address addr = getAddress(passwordHash, recoveryHash , salt);\\n        uint codeSize = addr.code.length;\\n        if (codeSize > 0) {\\n            return Celestial(payable(addr));\\n        }\\n        ret = Celestial(payable(new ERC1967Proxy{salt : bytes32(salt)}(\\n                address(CELESTIAL_IMPLEMENTATION),\\n                abi.encodeCall(Celestial.initialize, (passwordHash, recoveryHash))\\n            )));\\n        addCelestial(name, address(ret));\\n    }\\n\\n    function getAddress(bytes32 passwordHash, bytes32 recoveryHash, uint256 salt) public view returns (address) {\\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\\n            type(ERC1967Proxy).creationCode,\\n            abi.encode(\\n                address(CELESTIAL_IMPLEMENTATION),\\n                abi.encodeCall(Celestial.initialize, (passwordHash, recoveryHash))\\n            )\\n        )));\\n    }\\n\\n    function executeCelestialTx(string memory name, bytes calldata proof, address dest, uint256 value, bytes calldata func) onlyTrustedForwarder isValidCelestial(name) external returns (bool) {\\n        Celestial celestial = Celestial(payable(address(CelestialNameToDetails[name].walletAddress)));\\n\\n        return celestial.execute(proof, dest, value, func);\\n    }\\n\\n    function executeCelestialBatchTx(string memory name, bytes calldata proof, address[] calldata dests, uint256[] calldata values, bytes[] calldata funcs) onlyTrustedForwarder isValidCelestial(name) external returns (bool) {\\n        Celestial celestial = Celestial(payable(address(CelestialNameToDetails[name].walletAddress)));\\n\\n        return celestial.executeBatch(proof, dests, values, funcs);\\n    }\\n\\n    function executeCelestialPasskeyRecovery(string memory name, bytes calldata proof, bytes32 _passwordHash) onlyTrustedForwarder isValidCelestial(name) external returns (bool) {\\n        Celestial celestial = Celestial(payable(address(CelestialNameToDetails[name].walletAddress)));\\n\\n        return celestial.executePasskeyRecovery(proof, _passwordHash);\\n    }\\n\\n    function executeCelestialChangeRecovery(string memory name, bytes calldata proof, bytes32 _recoveryHash) onlyTrustedForwarder isValidCelestial(name) external returns (bool) {\\n        Celestial celestial = Celestial(payable(address(CelestialNameToDetails[name].walletAddress)));\\n\\n        return celestial.executeChangeRecovery(proof, _recoveryHash);\\n    }\\n}\",\"keccak256\":\"0x0f4bd153e9072f83d4cc66204f7599382be1ac7d2525953db8837db7bf5d5ccf\",\"license\":\"MIT\"},\"contracts/CelestialStorage.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\ncontract CelestialStorage {\\n    \\n    struct CelestialDetails {\\n        address walletAddress;\\n        bool isUsed;\\n    }\\n\\n    mapping(string => CelestialDetails) public CelestialNameToDetails;\\n\\n    function addCelestial(string memory name, address walletAddress) internal {\\n        CelestialNameToDetails[name] = CelestialDetails(walletAddress, true);\\n    }\\n\\n    function _checkCelestial(string memory name) internal view {\\n        require(CelestialNameToDetails[name].isUsed, \\\"Celestial: Invalid Celestial\\\");\\n    }\\n    \\n    function getCelestial(string memory name) external view returns (CelestialDetails memory) {\\n        CelestialDetails memory details = CelestialNameToDetails[name];\\n        return details;\\n    }\\n\\n    modifier isValidCelestial(string memory name) {\\n        _checkCelestial(name);\\n        _;\\n    }\\n\\n}\",\"keccak256\":\"0xdab81f855a3165ae31099453c81b81547e22176a4703cf3a1270a692facdd1f6\",\"license\":\"MIT\"},\"contracts/callback/TokenCallbackHandler.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-empty-blocks */\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\n/**\\n * Token callback handler.\\n *   Handles supported tokens' callbacks, allowing account receiving these tokens.\\n */\\ncontract TokenCallbackHandler is IERC777Recipient, IERC721Receiver, IERC1155Receiver {\\n    function tokensReceived(\\n        address,\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata,\\n        bytes calldata\\n    ) external pure override {\\n    }\\n\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC1155Receiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IERC721Receiver).interfaceId ||\\n            interfaceId == type(IERC1155Receiver).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n}\",\"keccak256\":\"0x26bd92d845796494079d4231e749bb41b89c4d05e2347affa2c2c80c49e032bf\",\"license\":\"GPL-3.0\"},\"contracts/utils/Conversion.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nlibrary Conversion {\\n    function convertInputs(bytes32 message, bytes32 pubkeyHash) internal pure returns (bytes32 [] memory){\\n        bytes32[] memory byte32Inputs = new bytes32[](64);\\n\\n        for (uint256 i = 0; i < 32; i++) {\\n            byte32Inputs[i] = convertToPaddedByte32(message[i]);\\n        }\\n\\n        for (uint256 i = 0; i < 32; i++) {\\n            byte32Inputs[i + 32] = convertToPaddedByte32(pubkeyHash[i]);\\n        }\\n\\n        return byte32Inputs;\\n    }\\n\\n    function convertToPaddedByte32(bytes32 value) internal pure returns (bytes32) {\\n        bytes32 paddedValue;\\n        paddedValue = bytes32(uint256(value) >> (31 * 8));\\n        return paddedValue;\\n    } \\n\\n    function hashMessage(string memory message) internal pure returns (bytes32) {\\n        string memory messagePrefix = \\\"\\\\x19Ethereum Signed Message:\\\\n\\\";\\n\\n        string memory lengthString = Strings.toString(bytes(message).length);\\n\\n        string memory concatenatedMessage = string(abi.encodePacked(messagePrefix, lengthString, message));\\n\\n        return keccak256(bytes(concatenatedMessage));\\n    }\\n\\n    function encodeDetails(address account, uint256 balance) internal pure returns (string memory) {\\n        bytes memory json = abi.encodePacked('{\\\"address\\\":\\\"', toString(account), '\\\",\\\"balance\\\":', Strings.toString(balance), '}');\\n        return base64Encode(json);\\n    }\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return Strings.toString(uint160(account));\\n    }\\n\\n    function encode(uint256 number) internal pure returns (uint256 result) {\\n        for (uint256 i = 0; i < 4; i++) {\\n            result |= (number & 0xFF) << (i * 8);\\n            number >>= 6;\\n        }\\n    }\\n\\n    function base64Encode(bytes memory data) internal pure returns (string memory) {\\n        string memory base64abc = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n        uint256 length = data.length;\\n        if (length == 0) return \\\"\\\";\\n        uint256 encodedLength = 4 * ((length + 2) / 3);\\n        string memory result = new string(encodedLength + encodedLength / 76);\\n        bytes memory resultBytes = bytes(result);\\n\\n        uint256 index = 0;\\n        uint256 counter = 0;\\n        for (uint256 i = 0; i < length; i += 3) {\\n            uint256 number = uint256(uint8(data[i])) << 16;\\n            if (i + 1 < length) number |= uint256(uint8(data[i + 1])) << 8;\\n            if (i + 2 < length) number |= uint256(uint8(data[i + 2]));\\n\\n            uint256 encoded = encode(number);\\n            for (uint256 j = 0; j < 4; j++) {\\n                if (i + j < length) {\\n                    resultBytes[index++] = bytes(base64abc)[encoded & 0xFF];\\n                } else {\\n                    resultBytes[index++] = \\\"=\\\";\\n                }\\n                encoded >>= 8;\\n            }\\n\\n            if (++counter == 19 && index < encodedLength) {\\n                resultBytes[index++] = \\\"\\\\n\\\";\\n                counter = 0;\\n            }\\n        }\\n\\n        return string(resultBytes);\\n    }\\n}\",\"keccak256\":\"0xefd21403ae5753bf20da0f17672b4bbb08abff10f834406fee85636c9a21140a\",\"license\":\"MIT\"},\"contracts/verifier/PasskeyVerifier.sol\":{\"content\":\"// Verification Key Hash: 791e5bf83d4a120ce048e8ed540d59e987cb2b03ab56b4919314e4c54fcffeb7\\n// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary PasskeyUltraVerificationKey {\\n    function verificationKeyHash() internal pure returns(bytes32) {\\n        return 0x791e5bf83d4a120ce048e8ed540d59e987cb2b03ab56b4919314e4c54fcffeb7;\\n    }\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure {\\n        assembly {\\n            mstore(add(_vk, 0x00), 0x0000000000000000000000000000000000000000000000000000000000000400) // vk.circuit_size\\n            mstore(add(_vk, 0x20), 0x0000000000000000000000000000000000000000000000000000000000000002) // vk.num_inputs\\n            mstore(add(_vk, 0x40), 0x06fd19c17017a420ebbebc2bb08771e339ba79c0a8d2d7ab11f995e1bc2e5912) // vk.work_root\\n            mstore(add(_vk, 0x60), 0x3058355f447953c1ade231a513e0f80710e9db4e679b02351f90fd168b040001) // vk.domain_inverse\\n            mstore(add(_vk, 0x80), 0x13468d673e62c677ea1f20e5d5aec31d44d7c2105511b1f2746a1172106f68b7) // vk.Q1.x\\n            mstore(add(_vk, 0xa0), 0x299e2a4b994d241fbdf4a9e44cb7266262d25c2ef5f46ecac90a11e1d78a66c1) // vk.Q1.y\\n            mstore(add(_vk, 0xc0), 0x1c1b49b3ee1c5e876b28d40b36bb0dee805b126fac84ee08be9ec37f3a3ae7b3) // vk.Q2.x\\n            mstore(add(_vk, 0xe0), 0x27c7ffb829e1102ca9635257088d31b9f6812c875c80c314390b1f9d906130aa) // vk.Q2.y\\n            mstore(add(_vk, 0x100), 0x26558619a3b5eebad038a17c77b99cf2e08f261aa5b33767f2fa4fb2242affc6) // vk.Q3.x\\n            mstore(add(_vk, 0x120), 0x183c9f2e44a9f23a835a61d6175177d1bb7d94c92108c20f15e84a3c26e6d18b) // vk.Q3.y\\n            mstore(add(_vk, 0x140), 0x164641abbfefd00a92aedbb56955d53bcb9a8629117c511f249fdb54123eabe7) // vk.Q4.x\\n            mstore(add(_vk, 0x160), 0x04ae93a1e0f621b694921ea5739253185db81bddba216ce43cb97f75d72a67b6) // vk.Q4.y\\n            mstore(add(_vk, 0x180), 0x0638ed6531e6e7e0e2e9b8f555d10d2c63d749d39e48fc977b241dab0989c2a5) // vk.Q_M.x\\n            mstore(add(_vk, 0x1a0), 0x21df080177f3205389b613556efbc03e48d4935d6169bf4c087d84c15b5c46af) // vk.Q_M.y\\n            mstore(add(_vk, 0x1c0), 0x002cbbb85f0c2ab267aaf8d3a28ff19220f4072ea836626ae7d157d27600d51b) // vk.Q_C.x\\n            mstore(add(_vk, 0x1e0), 0x28c5a27d37a2f3b5359d61032fef7823c0e2157bb5cf98d2025fa052f96feb62) // vk.Q_C.y\\n            mstore(add(_vk, 0x200), 0x21e9879420489ed32e9aa052f719609cc44ca83ecbcef7406e3cd04cb8fee11a) // vk.Q_ARITHMETIC.x\\n            mstore(add(_vk, 0x220), 0x085f7d6fb7df19b037bc107bab2a7951c8b69fe0d934f1d98f1fa82838fdfe79) // vk.Q_ARITHMETIC.y\\n            mstore(add(_vk, 0x240), 0x159ed02fe8a2f33e45d8cc2b9a5299e5ab5fe8c64ea16e75ff425cfe432b15ae) // vk.QSORT.x\\n            mstore(add(_vk, 0x260), 0x1672bb9ededb4427c9ef7e976e92b25a2a77d34ff29e700910b2621f45be73ad) // vk.QSORT.y\\n            mstore(add(_vk, 0x280), 0x273d40dd3bce751580483c8ead88f94535448de8088456fe83376e05cccbdc98) // vk.Q_ELLIPTIC.x\\n            mstore(add(_vk, 0x2a0), 0x2be69038eb9852beb166fd7755183ce25790491400ac1b7fc47628525702f1c3) // vk.Q_ELLIPTIC.y\\n            mstore(add(_vk, 0x2c0), 0x0b75803d020993aae12fff4b302511645807e72d327c5926373e9e8020dd24c2) // vk.Q_AUX.x\\n            mstore(add(_vk, 0x2e0), 0x24c953be9c18ddcafc2845fa8b22fb449ff1e375e71f9a4f199f390aba584c4e) // vk.Q_AUX.y\\n            mstore(add(_vk, 0x300), 0x026b9d74dc1683899fffb57f4cc4138cb47ad6a6a6a1e0df5be88ee89e7fa3f9) // vk.SIGMA1.x\\n            mstore(add(_vk, 0x320), 0x2ac7b49fcb4635b86a6336e440f66050fb2b290f5432e41f4672fe85f9c8f224) // vk.SIGMA1.y\\n            mstore(add(_vk, 0x340), 0x28d17650104713ca489576808547281c354d0aab35ac686c852de98a3a3512a8) // vk.SIGMA2.x\\n            mstore(add(_vk, 0x360), 0x234e386b36776b3468fcda188f3d4de79d5a942a0aa852119cef8845fb3395ef) // vk.SIGMA2.y\\n            mstore(add(_vk, 0x380), 0x15117f02b2c9dc8bbfca34b54e9e8852428dc32ec650a001868e1f5bf06941f7) // vk.SIGMA3.x\\n            mstore(add(_vk, 0x3a0), 0x0192ded53345a54e11b6dae8b4fc9646dcf8ce49977a7816fbad86ba5592e20f) // vk.SIGMA3.y\\n            mstore(add(_vk, 0x3c0), 0x1c70d28dceb8b95f6b4ca36f2b1d4537320098b21c29a84fe07a211f10dc5b28) // vk.SIGMA4.x\\n            mstore(add(_vk, 0x3e0), 0x06713a3a29a308ae0940dcb96bf1d627ca6979d4120761c0a45b17ee3488a2f2) // vk.SIGMA4.y\\n            mstore(add(_vk, 0x400), 0x2a8f38a4936cba151811671d5afeec5d7466709833ba96686626ff1ad1da4b7b) // vk.TABLE1.x\\n            mstore(add(_vk, 0x420), 0x0146ad4600c8edb6d0e56554c645120149cf7845ed8d2934f882de29bf3d05a6) // vk.TABLE1.y\\n            mstore(add(_vk, 0x440), 0x0108ef8c537ae19c420007cfcacf061de82808857de55bb1c111540df0f49ac8) // vk.TABLE2.x\\n            mstore(add(_vk, 0x460), 0x0446adf3fc100bbb58aeccf275df0982d9b2eaf43d36d15127b44975069cc00d) // vk.TABLE2.y\\n            mstore(add(_vk, 0x480), 0x19c364f5c0a4b4ab46439ec4f6b41e85bcb447b3b3d56c498fffb24a8e17803c) // vk.TABLE3.x\\n            mstore(add(_vk, 0x4a0), 0x261fa22dc105a5fb00af42838f77daf11f3dbfbc45adb698569860513d115f0b) // vk.TABLE3.y\\n            mstore(add(_vk, 0x4c0), 0x1e500c8c409983cf62fa4a2a223db1e322b5e25669fa77f09677ea7d4bea1271) // vk.TABLE4.x\\n            mstore(add(_vk, 0x4e0), 0x12a6c081b534d611b686901b6ffed9897e341d3b9ba734b7a2c51c3cd5d05ccb) // vk.TABLE4.y\\n            mstore(add(_vk, 0x500), 0x1c10d1c88a68ba01fa9f6c3010e9ae93892ca0617b390ccac9c78d9835e993ef) // vk.TABLE_TYPE.x\\n            mstore(add(_vk, 0x520), 0x0462aba4c9975a98994d929f88cbc50b4f6eb3a942f6a6948fac6ba0edc8557c) // vk.TABLE_TYPE.y\\n            mstore(add(_vk, 0x540), 0x150a4d4c3184f53153baf3b8b8b8b1b3d12fb14bef1ff5f161ff536ea1a00df8) // vk.ID1.x\\n            mstore(add(_vk, 0x560), 0x1c604a760b6ccb3a7ad23370973ea62c78a7a1a027abd1568032198ab983b970) // vk.ID1.y\\n            mstore(add(_vk, 0x580), 0x0af51f7e9551d0faa08d0fdd612b3c620e7e026b617bc11797d5e78df39ab87b) // vk.ID2.x\\n            mstore(add(_vk, 0x5a0), 0x0fec061961cf496737b631e5c83aa9624f9032c61d3669720cff8adbcf3c2264) // vk.ID2.y\\n            mstore(add(_vk, 0x5c0), 0x1af93f1aba582464219428ad5f35ab3c0a7969d1182987b620518c65447f86a6) // vk.ID3.x\\n            mstore(add(_vk, 0x5e0), 0x2f411da800e6f0ab514bdfa59096dbedb2283610d2cfc5435c67dc2f3a399c7c) // vk.ID3.y\\n            mstore(add(_vk, 0x600), 0x19cfadbc7fda954f3c36d34378570418ec1d97ead53329af7e08dd546721c295) // vk.ID4.x\\n            mstore(add(_vk, 0x620), 0x2f5dc9c95db6a149f5471339be980e43194633934ae1948be8263fcfd99d9c89) // vk.ID4.y\\n            mstore(add(_vk, 0x640), 0x00) // vk.contains_recursive_proof\\n            mstore(add(_vk, 0x660), 0) // vk.recursive_proof_public_input_indices\\n            mstore(add(_vk, 0x680), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1 \\n            mstore(add(_vk, 0x6a0), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0 \\n            mstore(add(_vk, 0x6c0), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1 \\n            mstore(add(_vk, 0x6e0), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0 \\n            mstore(_omegaInverseLoc, 0x1c4042c7de3c86d66ed809157a2c7f0aed42b68e6e43404ecaa2e1e9b2e5cc71) // vk.work_root_inverse\\n        }\\n    }\\n}\\n/**\\n * @title Ultra Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n */\\nabstract contract PasskeyBaseUltraVerifier {\\n    // VERIFICATION KEY MEMORY LOCATIONS\\n    uint256 internal constant N_LOC = 0x380;\\n    uint256 internal constant NUM_INPUTS_LOC = 0x3a0;\\n    uint256 internal constant OMEGA_LOC = 0x3c0;\\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x3e0;\\n    uint256 internal constant Q1_X_LOC = 0x400;\\n    uint256 internal constant Q1_Y_LOC = 0x420;\\n    uint256 internal constant Q2_X_LOC = 0x440;\\n    uint256 internal constant Q2_Y_LOC = 0x460;\\n    uint256 internal constant Q3_X_LOC = 0x480;\\n    uint256 internal constant Q3_Y_LOC = 0x4a0;\\n    uint256 internal constant Q4_X_LOC = 0x4c0;\\n    uint256 internal constant Q4_Y_LOC = 0x4e0;\\n    uint256 internal constant QM_X_LOC = 0x500;\\n    uint256 internal constant QM_Y_LOC = 0x520;\\n    uint256 internal constant QC_X_LOC = 0x540;\\n    uint256 internal constant QC_Y_LOC = 0x560;\\n    uint256 internal constant QARITH_X_LOC = 0x580;\\n    uint256 internal constant QARITH_Y_LOC = 0x5a0;\\n    uint256 internal constant QSORT_X_LOC = 0x5c0;\\n    uint256 internal constant QSORT_Y_LOC = 0x5e0;\\n    uint256 internal constant QELLIPTIC_X_LOC = 0x600;\\n    uint256 internal constant QELLIPTIC_Y_LOC = 0x620;\\n    uint256 internal constant QAUX_X_LOC = 0x640;\\n    uint256 internal constant QAUX_Y_LOC = 0x660;\\n    uint256 internal constant SIGMA1_X_LOC = 0x680;\\n    uint256 internal constant SIGMA1_Y_LOC = 0x6a0;\\n    uint256 internal constant SIGMA2_X_LOC = 0x6c0;\\n    uint256 internal constant SIGMA2_Y_LOC = 0x6e0;\\n    uint256 internal constant SIGMA3_X_LOC = 0x700;\\n    uint256 internal constant SIGMA3_Y_LOC = 0x720;\\n    uint256 internal constant SIGMA4_X_LOC = 0x740;\\n    uint256 internal constant SIGMA4_Y_LOC = 0x760;\\n    uint256 internal constant TABLE1_X_LOC = 0x780;\\n    uint256 internal constant TABLE1_Y_LOC = 0x7a0;\\n    uint256 internal constant TABLE2_X_LOC = 0x7c0;\\n    uint256 internal constant TABLE2_Y_LOC = 0x7e0;\\n    uint256 internal constant TABLE3_X_LOC = 0x800;\\n    uint256 internal constant TABLE3_Y_LOC = 0x820;\\n    uint256 internal constant TABLE4_X_LOC = 0x840;\\n    uint256 internal constant TABLE4_Y_LOC = 0x860;\\n    uint256 internal constant TABLE_TYPE_X_LOC = 0x880;\\n    uint256 internal constant TABLE_TYPE_Y_LOC = 0x8a0;\\n    uint256 internal constant ID1_X_LOC = 0x8c0;\\n    uint256 internal constant ID1_Y_LOC = 0x8e0;\\n    uint256 internal constant ID2_X_LOC = 0x900;\\n    uint256 internal constant ID2_Y_LOC = 0x920;\\n    uint256 internal constant ID3_X_LOC = 0x940;\\n    uint256 internal constant ID3_Y_LOC = 0x960;\\n    uint256 internal constant ID4_X_LOC = 0x980;\\n    uint256 internal constant ID4_Y_LOC = 0x9a0;\\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x9c0;\\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x9e0;\\n    uint256 internal constant G2X_X0_LOC = 0xa00;\\n    uint256 internal constant G2X_X1_LOC = 0xa20;\\n    uint256 internal constant G2X_Y0_LOC = 0xa40;\\n    uint256 internal constant G2X_Y1_LOC = 0xa60;\\n\\n    // ### PROOF DATA MEMORY LOCATIONS\\n    uint256 internal constant W1_X_LOC = 0x1200;\\n    uint256 internal constant W1_Y_LOC = 0x1220;\\n    uint256 internal constant W2_X_LOC = 0x1240;\\n    uint256 internal constant W2_Y_LOC = 0x1260;\\n    uint256 internal constant W3_X_LOC = 0x1280;\\n    uint256 internal constant W3_Y_LOC = 0x12a0;\\n    uint256 internal constant W4_X_LOC = 0x12c0;\\n    uint256 internal constant W4_Y_LOC = 0x12e0;\\n    uint256 internal constant S_X_LOC = 0x1300;\\n    uint256 internal constant S_Y_LOC = 0x1320;\\n    uint256 internal constant Z_X_LOC = 0x1340;\\n    uint256 internal constant Z_Y_LOC = 0x1360;\\n    uint256 internal constant Z_LOOKUP_X_LOC = 0x1380;\\n    uint256 internal constant Z_LOOKUP_Y_LOC = 0x13a0;\\n    uint256 internal constant T1_X_LOC = 0x13c0;\\n    uint256 internal constant T1_Y_LOC = 0x13e0;\\n    uint256 internal constant T2_X_LOC = 0x1400;\\n    uint256 internal constant T2_Y_LOC = 0x1420;\\n    uint256 internal constant T3_X_LOC = 0x1440;\\n    uint256 internal constant T3_Y_LOC = 0x1460;\\n    uint256 internal constant T4_X_LOC = 0x1480;\\n    uint256 internal constant T4_Y_LOC = 0x14a0;\\n\\n    uint256 internal constant W1_EVAL_LOC = 0x1600;\\n    uint256 internal constant W2_EVAL_LOC = 0x1620;\\n    uint256 internal constant W3_EVAL_LOC = 0x1640;\\n    uint256 internal constant W4_EVAL_LOC = 0x1660;\\n    uint256 internal constant S_EVAL_LOC = 0x1680;\\n    uint256 internal constant Z_EVAL_LOC = 0x16a0;\\n    uint256 internal constant Z_LOOKUP_EVAL_LOC = 0x16c0;\\n    uint256 internal constant Q1_EVAL_LOC = 0x16e0;\\n    uint256 internal constant Q2_EVAL_LOC = 0x1700;\\n    uint256 internal constant Q3_EVAL_LOC = 0x1720;\\n    uint256 internal constant Q4_EVAL_LOC = 0x1740;\\n    uint256 internal constant QM_EVAL_LOC = 0x1760;\\n    uint256 internal constant QC_EVAL_LOC = 0x1780;\\n    uint256 internal constant QARITH_EVAL_LOC = 0x17a0;\\n    uint256 internal constant QSORT_EVAL_LOC = 0x17c0;\\n    uint256 internal constant QELLIPTIC_EVAL_LOC = 0x17e0;\\n    uint256 internal constant QAUX_EVAL_LOC = 0x1800;\\n    uint256 internal constant TABLE1_EVAL_LOC = 0x1840;\\n    uint256 internal constant TABLE2_EVAL_LOC = 0x1860;\\n    uint256 internal constant TABLE3_EVAL_LOC = 0x1880;\\n    uint256 internal constant TABLE4_EVAL_LOC = 0x18a0;\\n    uint256 internal constant TABLE_TYPE_EVAL_LOC = 0x18c0;\\n    uint256 internal constant ID1_EVAL_LOC = 0x18e0;\\n    uint256 internal constant ID2_EVAL_LOC = 0x1900;\\n    uint256 internal constant ID3_EVAL_LOC = 0x1920;\\n    uint256 internal constant ID4_EVAL_LOC = 0x1940;\\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x1960;\\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x1980;\\n    uint256 internal constant SIGMA3_EVAL_LOC = 0x19a0;\\n    uint256 internal constant SIGMA4_EVAL_LOC = 0x19c0;\\n    uint256 internal constant W1_OMEGA_EVAL_LOC = 0x19e0;\\n    uint256 internal constant W2_OMEGA_EVAL_LOC = 0x2000;\\n    uint256 internal constant W3_OMEGA_EVAL_LOC = 0x2020;\\n    uint256 internal constant W4_OMEGA_EVAL_LOC = 0x2040;\\n    uint256 internal constant S_OMEGA_EVAL_LOC = 0x2060;\\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x2080;\\n    uint256 internal constant Z_LOOKUP_OMEGA_EVAL_LOC = 0x20a0;\\n    uint256 internal constant TABLE1_OMEGA_EVAL_LOC = 0x20c0;\\n    uint256 internal constant TABLE2_OMEGA_EVAL_LOC = 0x20e0;\\n    uint256 internal constant TABLE3_OMEGA_EVAL_LOC = 0x2100;\\n    uint256 internal constant TABLE4_OMEGA_EVAL_LOC = 0x2120;\\n\\n    uint256 internal constant PI_Z_X_LOC = 0x2300;\\n    uint256 internal constant PI_Z_Y_LOC = 0x2320;\\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x2340;\\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x2360;\\n\\n    // Used for elliptic widget. These are alias names for wire + shifted wire evaluations\\n    uint256 internal constant X1_EVAL_LOC = W2_EVAL_LOC;\\n    uint256 internal constant X2_EVAL_LOC = W1_OMEGA_EVAL_LOC;\\n    uint256 internal constant X3_EVAL_LOC = W2_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y1_EVAL_LOC = W3_EVAL_LOC;\\n    uint256 internal constant Y2_EVAL_LOC = W4_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y3_EVAL_LOC = W3_OMEGA_EVAL_LOC;\\n    uint256 internal constant QBETA_LOC = Q3_EVAL_LOC;\\n    uint256 internal constant QBETA_SQR_LOC = Q4_EVAL_LOC;\\n    uint256 internal constant QSIGN_LOC = Q1_EVAL_LOC;\\n\\n    // ### CHALLENGES MEMORY OFFSETS\\n\\n    uint256 internal constant C_BETA_LOC = 0x2600;\\n    uint256 internal constant C_GAMMA_LOC = 0x2620;\\n    uint256 internal constant C_ALPHA_LOC = 0x2640;\\n    uint256 internal constant C_ETA_LOC = 0x2660;\\n    uint256 internal constant C_ETA_SQR_LOC = 0x2680;\\n    uint256 internal constant C_ETA_CUBE_LOC = 0x26a0;\\n\\n    uint256 internal constant C_ZETA_LOC = 0x26c0;\\n    uint256 internal constant C_CURRENT_LOC = 0x26e0;\\n    uint256 internal constant C_V0_LOC = 0x2700;\\n    uint256 internal constant C_V1_LOC = 0x2720;\\n    uint256 internal constant C_V2_LOC = 0x2740;\\n    uint256 internal constant C_V3_LOC = 0x2760;\\n    uint256 internal constant C_V4_LOC = 0x2780;\\n    uint256 internal constant C_V5_LOC = 0x27a0;\\n    uint256 internal constant C_V6_LOC = 0x27c0;\\n    uint256 internal constant C_V7_LOC = 0x27e0;\\n    uint256 internal constant C_V8_LOC = 0x2800;\\n    uint256 internal constant C_V9_LOC = 0x2820;\\n    uint256 internal constant C_V10_LOC = 0x2840;\\n    uint256 internal constant C_V11_LOC = 0x2860;\\n    uint256 internal constant C_V12_LOC = 0x2880;\\n    uint256 internal constant C_V13_LOC = 0x28a0;\\n    uint256 internal constant C_V14_LOC = 0x28c0;\\n    uint256 internal constant C_V15_LOC = 0x28e0;\\n    uint256 internal constant C_V16_LOC = 0x2900;\\n    uint256 internal constant C_V17_LOC = 0x2920;\\n    uint256 internal constant C_V18_LOC = 0x2940;\\n    uint256 internal constant C_V19_LOC = 0x2960;\\n    uint256 internal constant C_V20_LOC = 0x2980;\\n    uint256 internal constant C_V21_LOC = 0x29a0;\\n    uint256 internal constant C_V22_LOC = 0x29c0;\\n    uint256 internal constant C_V23_LOC = 0x29e0;\\n    uint256 internal constant C_V24_LOC = 0x2a00;\\n    uint256 internal constant C_V25_LOC = 0x2a20;\\n    uint256 internal constant C_V26_LOC = 0x2a40;\\n    uint256 internal constant C_V27_LOC = 0x2a60;\\n    uint256 internal constant C_V28_LOC = 0x2a80;\\n    uint256 internal constant C_V29_LOC = 0x2aa0;\\n    uint256 internal constant C_V30_LOC = 0x2ac0;\\n\\n    uint256 internal constant C_U_LOC = 0x2b00;\\n\\n    // ### LOCAL VARIABLES MEMORY OFFSETS\\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x3000;\\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x3020;\\n    uint256 internal constant ZETA_POW_N_LOC = 0x3040;\\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x3060;\\n    uint256 internal constant ZERO_POLY_LOC = 0x3080;\\n    uint256 internal constant L_START_LOC = 0x30a0;\\n    uint256 internal constant L_END_LOC = 0x30c0;\\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x30e0;\\n\\n    uint256 internal constant PLOOKUP_DELTA_NUMERATOR_LOC = 0x3100;\\n    uint256 internal constant PLOOKUP_DELTA_DENOMINATOR_LOC = 0x3120;\\n    uint256 internal constant PLOOKUP_DELTA_LOC = 0x3140;\\n\\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x3160;\\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x3180;\\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x31a0;\\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x31c0;\\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x31e0;\\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x3200;\\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x3220;\\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x3240;\\n\\n    // ### SUCCESS FLAG MEMORY LOCATIONS\\n    uint256 internal constant GRAND_PRODUCT_SUCCESS_FLAG = 0x3300;\\n    uint256 internal constant ARITHMETIC_TERM_SUCCESS_FLAG = 0x3020;\\n    uint256 internal constant BATCH_OPENING_SUCCESS_FLAG = 0x3340;\\n    uint256 internal constant OPENING_COMMITMENT_SUCCESS_FLAG = 0x3360;\\n    uint256 internal constant PAIRING_PREAMBLE_SUCCESS_FLAG = 0x3380;\\n    uint256 internal constant PAIRING_SUCCESS_FLAG = 0x33a0;\\n    uint256 internal constant RESULT_FLAG = 0x33c0;\\n\\n    // misc stuff\\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x3400;\\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x3420;\\n    uint256 internal constant C_ALPHA_CUBE_LOC = 0x3440;\\n    uint256 internal constant C_ALPHA_QUAD_LOC = 0x3460;\\n    uint256 internal constant C_ALPHA_BASE_LOC = 0x3480;\\n\\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x3500;\\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x3520;\\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x3540;\\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x3560;\\n\\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x3580;\\n\\n    // sub-identity storage\\n    uint256 internal constant PERMUTATION_IDENTITY = 0x3600;\\n    uint256 internal constant PLOOKUP_IDENTITY = 0x3620;\\n    uint256 internal constant ARITHMETIC_IDENTITY = 0x3640;\\n    uint256 internal constant SORT_IDENTITY = 0x3660;\\n    uint256 internal constant ELLIPTIC_IDENTITY = 0x3680;\\n    uint256 internal constant AUX_IDENTITY = 0x36a0;\\n    uint256 internal constant AUX_NON_NATIVE_FIELD_EVALUATION = 0x36c0;\\n    uint256 internal constant AUX_LIMB_ACCUMULATOR_EVALUATION = 0x36e0;\\n    uint256 internal constant AUX_RAM_CONSISTENCY_EVALUATION = 0x3700;\\n    uint256 internal constant AUX_ROM_CONSISTENCY_EVALUATION = 0x3720;\\n    uint256 internal constant AUX_MEMORY_EVALUATION = 0x3740;\\n\\n    uint256 internal constant QUOTIENT_EVAL_LOC = 0x3760;\\n    uint256 internal constant ZERO_POLY_INVERSE_LOC = 0x3780;\\n\\n    // when hashing public inputs we use memory at NU_CHALLENGE_INPUT_LOC_A, as the hash input size is unknown at compile time\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_A = 0x37a0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_B = 0x37c0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_C = 0x37e0;\\n\\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR = 0xeba9f4a6;\\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\\n    bytes4 internal constant EC_SCALAR_MUL_FAILURE_SELECTOR = 0xf755f369;\\n    bytes4 internal constant PROOF_FAILURE_SELECTOR = 0x0711fcec;\\n\\n    uint256 internal constant ETA_INPUT_LENGTH = 0xc0; // W1, W2, W3 = 6 * 0x20 bytes\\n\\n    // We need to hash 41 field elements when generating the NU challenge\\n    // w1, w2, w3, w4, s, z, z_lookup, q1, q2, q3, q4, qm, qc, qarith (14)\\n    // qsort, qelliptic, qaux, sigma1, sigma2, sigma, sigma4, (7)\\n    // table1, table2, table3, table4, tabletype, id1, id2, id3, id4, (9)\\n    // w1_omega, w2_omega, w3_omega, w4_omega, s_omega, z_omega, z_lookup_omega, (7)\\n    // table1_omega, table2_omega, table3_omega, table4_omega (4)\\n    uint256 internal constant NU_INPUT_LENGTH = 0x520; // 0x520 = 41 * 0x20\\n\\n    // There are ELEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n    // W1, W2, W3, W4, S, Z, Z_LOOKUP, T1, T2, T3, T4\\n    uint256 internal constant NU_CALLDATA_SKIP_LENGTH = 0x2c0; // 11 * 0x40 = 0x2c0\\n\\n    uint256 internal constant NEGATIVE_INVERSE_OF_2_MODULO_P =\\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    uint256 internal constant LIMB_SIZE = 0x100000000000000000; // 2<<68\\n    uint256 internal constant SUBLIMB_SHIFT = 0x4000; // 2<<14\\n\\n    // y^2 = x^3 + ax + b\\n    // for Grumpkin, a = 0 and b = -17. We use b in a custom gate relation that evaluates elliptic curve arithmetic\\n    uint256 internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = 17;\\n    error PUBLIC_INPUT_COUNT_INVALID(uint256 expected, uint256 actual);\\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\\n    error PUBLIC_INPUT_GE_P();\\n    error MOD_EXP_FAILURE();\\n    error EC_SCALAR_MUL_FAILURE();\\n    error PROOF_FAILURE();\\n\\n    function getVerificationKeyHash() public pure virtual returns (bytes32);\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure virtual;\\n\\n    /**\\n     * @notice Verify a Ultra Plonk proof\\n     * @param _proof - The serialized proof\\n     * @param _publicInputs - An array of the public inputs\\n     * @return True if proof is valid, reverts otherwise\\n     */\\n    function verify(bytes calldata _proof, bytes32[] memory _publicInputs) external view returns (bool) {\\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\\n\\n        uint256 requiredPublicInputCount;\\n        assembly {\\n            requiredPublicInputCount := mload(NUM_INPUTS_LOC)\\n        }\\n        if (requiredPublicInputCount != _publicInputs.length) {\\n            revert PUBLIC_INPUT_COUNT_INVALID(requiredPublicInputCount, _publicInputs.length);\\n        }\\n\\n        assembly {\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\\n\\n            /**\\n             * LOAD PROOF FROM CALLDATA\\n             */\\n            {\\n                let data_ptr := add(calldataload(0x04), 0x24)\\n\\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\\n\\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\\n\\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\\n\\n                mstore(W4_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\\n                mstore(W4_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\\n\\n                mstore(S_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\\n                mstore(S_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\\n                mstore(Z_LOOKUP_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\\n                mstore(Z_LOOKUP_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x1c0)), q))\\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x1e0)), q))\\n\\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x200)), q))\\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x220)), q))\\n\\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x240)), q))\\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x260)), q))\\n\\n                mstore(T4_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\\n                mstore(T4_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\\n\\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2c0)), p))\\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2e0)), p))\\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x300)), p))\\n                mstore(W4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x320)), p))\\n                mstore(S_EVAL_LOC, mod(calldataload(add(data_ptr, 0x340)), p))\\n                mstore(Z_EVAL_LOC, mod(calldataload(add(data_ptr, 0x360)), p))\\n                mstore(Z_LOOKUP_EVAL_LOC, mod(calldataload(add(data_ptr, 0x380)), p))\\n                mstore(Q1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3a0)), p))\\n                mstore(Q2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3c0)), p))\\n                mstore(Q3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3e0)), p))\\n                mstore(Q4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x400)), p))\\n                mstore(QM_EVAL_LOC, mod(calldataload(add(data_ptr, 0x420)), p))\\n                mstore(QC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x440)), p))\\n                mstore(QARITH_EVAL_LOC, mod(calldataload(add(data_ptr, 0x460)), p))\\n                mstore(QSORT_EVAL_LOC, mod(calldataload(add(data_ptr, 0x480)), p))\\n                mstore(QELLIPTIC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4a0)), p))\\n                mstore(QAUX_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4c0)), p))\\n\\n                mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4e0)), p))\\n                mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x500)), p))\\n\\n                mstore(SIGMA3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x520)), p))\\n                mstore(SIGMA4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x540)), p))\\n\\n                mstore(TABLE1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x560)), p))\\n                mstore(TABLE2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x580)), p))\\n                mstore(TABLE3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5a0)), p))\\n                mstore(TABLE4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5c0)), p))\\n                mstore(TABLE_TYPE_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5e0)), p))\\n\\n                mstore(ID1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x600)), p))\\n                mstore(ID2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x620)), p))\\n                mstore(ID3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x640)), p))\\n                mstore(ID4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x660)), p))\\n\\n                mstore(W1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x680)), p))\\n                mstore(W2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6a0)), p))\\n                mstore(W3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6c0)), p))\\n                mstore(W4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6e0)), p))\\n                mstore(S_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x700)), p))\\n\\n                mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x720)), p))\\n\\n                mstore(Z_LOOKUP_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x740)), p))\\n                mstore(TABLE1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x760)), p))\\n                mstore(TABLE2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x780)), p))\\n                mstore(TABLE3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7a0)), p))\\n                mstore(TABLE4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7c0)), p))\\n\\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x7e0)), q))\\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x800)), q))\\n\\n                mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x820)), q))\\n                mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x840)), q))\\n            }\\n\\n            /**\\n             * LOAD RECURSIVE PROOF INTO MEMORY\\n             */\\n            {\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n                    let index_counter := add(shl(5, mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC)), public_inputs_ptr)\\n\\n                    let x0 := calldataload(index_counter)\\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                    let y0 := calldataload(add(index_counter, 0x80))\\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                    let x1 := calldataload(add(index_counter, 0x100))\\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                    let y1 := calldataload(add(index_counter, 0x180))\\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n                    mstore(RECURSIVE_P1_X_LOC, x0)\\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\\n                    mstore(RECURSIVE_P2_X_LOC, x1)\\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\\n\\n                    // validate these are valid bn128 G1 points\\n                    if iszero(and(and(lt(x0, q), lt(x1, q)), and(lt(y0, q), lt(y1, q)))) {\\n                        mstore(0x00, PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * Generate initial challenge\\n                 */\\n                mstore(0x00, shl(224, mload(N_LOC)))\\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\\n                let challenge := keccak256(0x00, 0x08)\\n\\n                /**\\n                 * Generate eta challenge\\n                 */\\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\\n                // The public input location is stored at 0x24, we then add 0x24 to skip selector and the length of public inputs\\n                let public_inputs_start := add(calldataload(0x24), 0x24)\\n                // copy the public inputs over\\n                let public_input_size := mul(mload(NUM_INPUTS_LOC), 0x20)\\n                calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_inputs_start, public_input_size)\\n\\n                // copy W1, W2, W3 into challenge. Each point is 0x40 bytes, so load 0xc0 = 3 * 0x40 bytes (ETA input length)\\n                let w_start := add(calldataload(0x04), 0x24)\\n                calldatacopy(add(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_input_size), w_start, ETA_INPUT_LENGTH)\\n\\n                // Challenge is the old challenge + public inputs + W1, W2, W3 (0x20 + public_input_size + 0xc0)\\n                let challenge_bytes_size := add(0x20, add(public_input_size, ETA_INPUT_LENGTH))\\n\\n                challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, challenge_bytes_size)\\n                {\\n                    let eta := mod(challenge, p)\\n                    mstore(C_ETA_LOC, eta)\\n                    mstore(C_ETA_SQR_LOC, mulmod(eta, eta, p))\\n                    mstore(C_ETA_CUBE_LOC, mulmod(mload(C_ETA_SQR_LOC), eta, p))\\n                }\\n\\n                /**\\n                 * Generate beta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(W4_Y_LOC))\\n                mstore(0x40, mload(W4_X_LOC))\\n                mstore(0x60, mload(S_Y_LOC))\\n                mstore(0x80, mload(S_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_BETA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate gamma challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_GAMMA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate alpha challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(Z_Y_LOC))\\n                mstore(0x40, mload(Z_X_LOC))\\n                mstore(0x60, mload(Z_LOOKUP_Y_LOC))\\n                mstore(0x80, mload(Z_LOOKUP_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_ALPHA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Compute and store some powers of alpha for future computations\\n                 */\\n                let alpha := mload(C_ALPHA_LOC)\\n                mstore(C_ALPHA_SQR_LOC, mulmod(alpha, alpha, p))\\n                mstore(C_ALPHA_CUBE_LOC, mulmod(mload(C_ALPHA_SQR_LOC), alpha, p))\\n                mstore(C_ALPHA_QUAD_LOC, mulmod(mload(C_ALPHA_CUBE_LOC), alpha, p))\\n                mstore(C_ALPHA_BASE_LOC, alpha)\\n\\n                /**\\n                 * Generate zeta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(T1_Y_LOC))\\n                mstore(0x40, mload(T1_X_LOC))\\n                mstore(0x60, mload(T2_Y_LOC))\\n                mstore(0x80, mload(T2_X_LOC))\\n                mstore(0xa0, mload(T3_Y_LOC))\\n                mstore(0xc0, mload(T3_X_LOC))\\n                mstore(0xe0, mload(T4_Y_LOC))\\n                mstore(0x100, mload(T4_X_LOC))\\n\\n                challenge := keccak256(0x00, 0x120)\\n\\n                mstore(C_ZETA_LOC, mod(challenge, p))\\n                mstore(C_CURRENT_LOC, challenge)\\n            }\\n\\n            /**\\n             * EVALUATE FIELD OPERATIONS\\n             */\\n\\n            /**\\n             * COMPUTE PUBLIC INPUT DELTA\\n             * \\u0394PI = \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3(i) + \\u03b3) / \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3'(i) + \\u03b3)\\n             */\\n            {\\n                let beta := mload(C_BETA_LOC) // \\u03b2\\n                let gamma := mload(C_GAMMA_LOC) // \\u03b3\\n                let work_root := mload(OMEGA_LOC) // \\u03c9\\n                let numerator_value := 1\\n                let denominator_value := 1\\n\\n                let p_clone := p // move p to the front of the stack\\n                let valid_inputs := true\\n\\n                // Load the starting point of the public inputs (jump over the selector and the length of public inputs [0x24])\\n                let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n\\n                // endpoint_ptr = public_inputs_ptr + num_inputs * 0x20. // every public input is 0x20 bytes\\n                let endpoint_ptr := add(public_inputs_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\\n\\n                // root_1 = \\u03b2 * 0x05\\n                let root_1 := mulmod(beta, 0x05, p_clone) // k1.\\u03b2\\n                // root_2 = \\u03b2 * 0x0c\\n                let root_2 := mulmod(beta, 0x0c, p_clone)\\n                // @note 0x05 + 0x07 == 0x0c == external coset generator\\n\\n                for {} lt(public_inputs_ptr, endpoint_ptr) { public_inputs_ptr := add(public_inputs_ptr, 0x20) } {\\n                    /**\\n                     * input = public_input[i]\\n                     * valid_inputs &= input < p\\n                     * temp = input + gamma\\n                     * numerator_value *= (\\u03b2.\\u03c3(i) + w\\u1d62 + \\u03b3)  // \\u03c3(i) = 0x05.\\u03c9\\u2071\\n                     * denominator_value *= (\\u03b2.\\u03c3'(i) + w\\u1d62 + \\u03b3) // \\u03c3'(i) = 0x0c.\\u03c9\\u2071\\n                     * root_1 *= \\u03c9\\n                     * root_2 *= \\u03c9\\n                     */\\n\\n                    let input := calldataload(public_inputs_ptr)\\n                    valid_inputs := and(valid_inputs, lt(input, p_clone))\\n                    let temp := addmod(input, gamma, p_clone)\\n\\n                    numerator_value := mulmod(numerator_value, add(root_1, temp), p_clone)\\n                    denominator_value := mulmod(denominator_value, add(root_2, temp), p_clone)\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n                }\\n\\n                // Revert if not all public inputs are field elements (i.e. < p)\\n                if iszero(valid_inputs) {\\n                    mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n\\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\\n            }\\n\\n            /**\\n             * Compute Plookup delta factor [\\u03b3(1 + \\u03b2)]^{n-k}\\n             * k = num roots cut out of Z_H = 4\\n             */\\n            {\\n                let delta_base := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let delta_numerator := delta_base\\n                {\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        delta_numerator := mulmod(delta_numerator, delta_numerator, p)\\n                    }\\n                }\\n                mstore(PLOOKUP_DELTA_NUMERATOR_LOC, delta_numerator)\\n\\n                let delta_denominator := mulmod(delta_base, delta_base, p)\\n                delta_denominator := mulmod(delta_denominator, delta_denominator, p)\\n                mstore(PLOOKUP_DELTA_DENOMINATOR_LOC, delta_denominator)\\n            }\\n            /**\\n             * Compute lagrange poly and vanishing poly fractions\\n             */\\n            {\\n                /**\\n                 * vanishing_numerator = zeta\\n                 * ZETA_POW_N = zeta^n\\n                 * vanishing_numerator -= 1\\n                 * accumulating_root = omega_inverse\\n                 * work_root = p - accumulating_root\\n                 * domain_inverse = domain_inverse\\n                 * vanishing_denominator = zeta + work_root\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * vanishing_denominator *= (zeta + (zeta + accumulating_root))\\n                 * work_root = omega\\n                 * lagrange_numerator = vanishing_numerator * domain_inverse\\n                 * l_start_denominator = zeta - 1\\n                 * accumulating_root = work_root^2\\n                 * l_end_denominator = accumulating_root^2 * work_root * zeta - 1\\n                 * Note: l_end_denominator term contains a term \\\\omega^5 to cut out 5 roots of unity from vanishing poly\\n                 */\\n\\n                let zeta := mload(C_ZETA_LOC)\\n\\n                // compute zeta^n, where n is a power of 2\\n                let vanishing_numerator := zeta\\n                {\\n                    // pow_small\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\\n                    }\\n                }\\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n\\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\\n                let work_root := sub(p, accumulating_root)\\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\\n\\n                let vanishing_denominator := addmod(zeta, work_root, p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                vanishing_denominator :=\\n                    mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\\n\\n                work_root := mload(OMEGA_LOC)\\n\\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\\n\\n                accumulating_root := mulmod(work_root, work_root, p)\\n\\n                let l_end_denominator :=\\n                    addmod(\\n                        mulmod(mulmod(mulmod(accumulating_root, accumulating_root, p), work_root, p), zeta, p), sub(p, 1), p\\n                    )\\n\\n                /**\\n                 * Compute inversions using Montgomery's batch inversion trick\\n                 */\\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\\n                let t0 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n                let t1 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n                let t2 := accumulator\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n                let t3 := accumulator\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n                let t4 := accumulator\\n                {\\n                    mstore(0, 0x20)\\n                    mstore(0x20, 0x20)\\n                    mstore(0x40, 0x20)\\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\\n                    mstore(0x80, sub(p, 2))\\n                    mstore(0xa0, p)\\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                    accumulator := mload(0x00)\\n                }\\n\\n                t4 := mulmod(accumulator, t4, p)\\n                accumulator := mulmod(accumulator, l_end_denominator, p)\\n\\n                t3 := mulmod(accumulator, t3, p)\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n\\n                t2 := mulmod(accumulator, t2, p)\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n\\n                t1 := mulmod(accumulator, t1, p)\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n\\n                t0 := mulmod(accumulator, t0, p)\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n\\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\\n\\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\\n                mstore(ZERO_POLY_INVERSE_LOC, mulmod(vanishing_denominator, t1, p))\\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t2, p))\\n                mstore(PLOOKUP_DELTA_LOC, mulmod(mload(PLOOKUP_DELTA_NUMERATOR_LOC), t3, p))\\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t4, p))\\n            }\\n\\n            /**\\n             * UltraPlonk Widget Ordering:\\n             *\\n             * 1. Permutation widget\\n             * 2. Plookup widget\\n             * 3. Arithmetic widget\\n             * 4. Fixed base widget (?)\\n             * 5. GenPermSort widget\\n             * 6. Elliptic widget\\n             * 7. Auxiliary widget\\n             */\\n\\n            /**\\n             * COMPUTE PERMUTATION WIDGET EVALUATION\\n             */\\n            {\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta := mload(C_BETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n\\n                /**\\n                 * t1 = (W1 + gamma + beta * ID1) * (W2 + gamma + beta * ID2)\\n                 * t2 = (W3 + gamma + beta * ID3) * (W4 + gamma + beta * ID4)\\n                 * result = alpha_base * z_eval * t1 * t2\\n                 * t1 = (W1 + gamma + beta * sigma_1_eval) * (W2 + gamma + beta * sigma_2_eval)\\n                 * t2 = (W2 + gamma + beta * sigma_3_eval) * (W3 + gamma + beta * sigma_4_eval)\\n                 * result -= (alpha_base * z_omega_eval * t1 * t2)\\n                 */\\n                let t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(ID1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(ID2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(ID3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(ID4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let result := mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_EVAL_LOC), mulmod(t1, t2, p), p), p)\\n                t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                result :=\\n                    addmod(\\n                        result,\\n                        sub(p, mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_OMEGA_EVAL_LOC), mulmod(t1, t2, p), p), p)),\\n                        p\\n                    )\\n\\n                /**\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_{n-k}(\\u0293) . (z(\\u0293.\\u03c9) - \\u2206_{PI}))\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_1(\\u0293)(Z(\\u0293) - 1))\\n                 * alpha_Base *= alpha\\n                 */\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                result :=\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(\\n                                mload(L_END_LOC),\\n                                addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                mstore(\\n                    PERMUTATION_IDENTITY,\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(mload(L_START_LOC), addmod(mload(Z_EVAL_LOC), sub(p, 1), p), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE PLOOKUP WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * Goal: f = (w1(z) + q2.w1(z\\u03c9)) + \\u03b7(w2(z) + qm.w2(z\\u03c9)) + \\u03b7\\u00b2(w3(z) + qc.w_3(z\\u03c9)) + q3(z).\\u03b7\\u00b3\\n                 * f = \\u03b7.q3(z)\\n                 * f += (w3(z) + qc.w_3(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w2(z) + qm.w2(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w1(z) + q2.w1(z\\u03c9))\\n                 */\\n                let f := mulmod(mload(C_ETA_LOC), mload(Q3_EVAL_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W3_EVAL_LOC), mulmod(mload(QC_EVAL_LOC), mload(W3_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W2_EVAL_LOC), mulmod(mload(QM_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W1_EVAL_LOC), mulmod(mload(Q2_EVAL_LOC), mload(W1_OMEGA_EVAL_LOC), p), p), p)\\n\\n                // t(z) = table4(z).\\u03b7\\u00b3 + table3(z).\\u03b7\\u00b2 + table2(z).\\u03b7 + table1(z)\\n                let t :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_EVAL_LOC),\\n                        p\\n                    )\\n\\n                // t(zw) = table4(zw).\\u03b7\\u00b3 + table3(zw).\\u03b7\\u00b2 + table2(zw).\\u03b7 + table1(zw)\\n                let t_omega :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_OMEGA_EVAL_LOC),\\n                        p\\n                    )\\n\\n                /**\\n                 * Goal: numerator = (TABLE_TYPE_EVAL * f(z) + \\u03b3) * (t(z) + \\u03b2t(z\\u03c9) + \\u03b3(\\u03b2 + 1)) * (\\u03b2 + 1)\\n                 * gamma_beta_constant = \\u03b3(\\u03b2 + 1)\\n                 * numerator = f * TABLE_TYPE_EVAL + gamma\\n                 * temp0 = t(z) + t(z\\u03c9) * \\u03b2 + gamma_beta_constant\\n                 * numerator *= temp0\\n                 * numerator *= (\\u03b2 + 1)\\n                 * temp0 = alpha * l_1\\n                 * numerator += temp0\\n                 * numerator *= z_lookup(z)\\n                 * numerator -= temp0\\n                 */\\n                let gamma_beta_constant := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let numerator := addmod(mulmod(f, mload(TABLE_TYPE_EVAL_LOC), p), mload(C_GAMMA_LOC), p)\\n                let temp0 := addmod(addmod(t, mulmod(t_omega, mload(C_BETA_LOC), p), p), gamma_beta_constant, p)\\n                numerator := mulmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, addmod(mload(C_BETA_LOC), 1, p), p)\\n                temp0 := mulmod(mload(C_ALPHA_LOC), mload(L_START_LOC), p)\\n                numerator := addmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, mload(Z_LOOKUP_EVAL_LOC), p)\\n                numerator := addmod(numerator, sub(p, temp0), p)\\n\\n                /**\\n                 * Goal: denominator = z_lookup(z\\u03c9)*[s(z) + \\u03b2s(z\\u03c9) + \\u03b3(1 + \\u03b2)] - [z_lookup(z\\u03c9) - [\\u03b3(1 + \\u03b2)]^{n-k}]*\\u03b1\\u00b2L_end(z)\\n                 * note: delta_factor = [\\u03b3(1 + \\u03b2)]^{n-k}\\n                 * denominator = s(z) + \\u03b2s(z\\u03c9) + \\u03b3(\\u03b2 + 1)\\n                 * temp1 = \\u03b1\\u00b2L_end(z)\\n                 * denominator -= temp1\\n                 * denominator *= z_lookup(z\\u03c9)\\n                 * denominator += temp1 * delta_factor\\n                 * PLOOKUP_IDENTITY = (numerator - denominator).alpha_base\\n                 * alpha_base *= alpha^3\\n                 */\\n                let denominator :=\\n                    addmod(\\n                        addmod(mload(S_EVAL_LOC), mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_BETA_LOC), p), p),\\n                        gamma_beta_constant,\\n                        p\\n                    )\\n                let temp1 := mulmod(mload(C_ALPHA_SQR_LOC), mload(L_END_LOC), p)\\n                denominator := addmod(denominator, sub(p, temp1), p)\\n                denominator := mulmod(denominator, mload(Z_LOOKUP_OMEGA_EVAL_LOC), p)\\n                denominator := addmod(denominator, mulmod(temp1, mload(PLOOKUP_DELTA_LOC), p), p)\\n\\n                mstore(PLOOKUP_IDENTITY, mulmod(addmod(numerator, sub(p, denominator), p), mload(C_ALPHA_BASE_LOC), p))\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ARITHMETIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * The basic arithmetic gate identity in standard plonk is as follows.\\n                 * (w_1 . w_2 . q_m) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c = 0\\n                 * However, for Ultraplonk, we extend this to support \\\"passing\\\" wires between rows (shown without alpha scaling below):\\n                 * q_arith * ( ( (-1/2) * (q_arith - 3) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c ) +\\n                 * (q_arith - 1)*( \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m) + w_4_omega) ) = 0\\n                 *\\n                 * This formula results in several cases depending on q_arith:\\n                 * 1. q_arith == 0: Arithmetic gate is completely disabled\\n                 *\\n                 * 2. q_arith == 1: Everything in the minigate on the right is disabled. The equation is just a standard plonk equation\\n                 * with extra wires: q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c = 0\\n                 *\\n                 * 3. q_arith == 2: The (w_1 + w_4 - ...) term is disabled. THe equation is:\\n                 * (1/2) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + w_4_omega = 0\\n                 * It allows defining w_4 at next index (w_4_omega) in terms of current wire values\\n                 *\\n                 * 4. q_arith == 3: The product of w_1 and w_2 is disabled, but a mini addition gate is enabled. \\u03b1 allows us to split\\n                 * the equation into two:\\n                 *\\n                 * q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + 2 * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0  (we are reusing q_m here)\\n                 *\\n                 * 5. q_arith > 3: The product of w_1 and w_2 is scaled by (q_arith - 3), while the w_4_omega term is scaled by (q_arith - 1).\\n                 * The equation can be split into two:\\n                 *\\n                 * (q_arith - 3)* q_m * w_1 * w_ 2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + (q_arith - 1) * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0\\n                 *\\n                 * The problem that q_m is used both in both equations can be dealt with by appropriately changing selector values at\\n                 * the next gate. Then we can treat (q_arith - 1) as a simulated q_6 selector and scale q_m to handle (q_arith - 3) at\\n                 * product.\\n                 */\\n\\n                let w1q1 := mulmod(mload(W1_EVAL_LOC), mload(Q1_EVAL_LOC), p)\\n                let w2q2 := mulmod(mload(W2_EVAL_LOC), mload(Q2_EVAL_LOC), p)\\n                let w3q3 := mulmod(mload(W3_EVAL_LOC), mload(Q3_EVAL_LOC), p)\\n                let w4q3 := mulmod(mload(W4_EVAL_LOC), mload(Q4_EVAL_LOC), p)\\n\\n                // @todo - Add a explicit test that hits QARITH == 3\\n                // w1w2qm := (w_1 . w_2 . q_m . (QARITH_EVAL_LOC - 3)) / 2\\n                let w1w2qm :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(mulmod(mload(W1_EVAL_LOC), mload(W2_EVAL_LOC), p), mload(QM_EVAL_LOC), p),\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 3), p),\\n                            p\\n                        ),\\n                        NEGATIVE_INVERSE_OF_2_MODULO_P,\\n                        p\\n                    )\\n\\n                // (w_1 . w_2 . q_m . (q_arith - 3)) / -2) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c\\n                let identity :=\\n                    addmod(\\n                        mload(QC_EVAL_LOC), addmod(w4q3, addmod(w3q3, addmod(w2q2, addmod(w1q1, w1w2qm, p), p), p), p), p\\n                    )\\n\\n                // if q_arith == 3 we evaluate an additional mini addition gate (on top of the regular one), where:\\n                // w_1 + w_4 - w_1_omega + q_m = 0\\n                // we use this gate to save an addition gate when adding or subtracting non-native field elements\\n                // \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m)\\n                let extra_small_addition_gate_identity :=\\n                    mulmod(\\n                        mload(C_ALPHA_LOC),\\n                        mulmod(\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 2), p),\\n                            addmod(\\n                                mload(QM_EVAL_LOC),\\n                                addmod(\\n                                    sub(p, mload(W1_OMEGA_EVAL_LOC)), addmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p), p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                // if q_arith == 2 OR q_arith == 3 we add the 4th wire of the NEXT gate into the arithmetic identity\\n                // N.B. if q_arith > 2, this wire value will be scaled by (q_arith - 1) relative to the other gate wires!\\n                // alpha_base * q_arith * (identity + (q_arith - 1) * (w_4_omega + extra_small_addition_gate_identity))\\n                mstore(\\n                    ARITHMETIC_IDENTITY,\\n                    mulmod(\\n                        mload(C_ALPHA_BASE_LOC),\\n                        mulmod(\\n                            mload(QARITH_EVAL_LOC),\\n                            addmod(\\n                                identity,\\n                                mulmod(\\n                                    addmod(mload(QARITH_EVAL_LOC), sub(p, 1), p),\\n                                    addmod(mload(W4_OMEGA_EVAL_LOC), extra_small_addition_gate_identity, p),\\n                                    p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE GENPERMSORT WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * D1 = (w2 - w1)\\n                 * D2 = (w3 - w2)\\n                 * D3 = (w4 - w3)\\n                 * D4 = (w1_omega - w4)\\n                 *\\n                 * \\u03b1_a = alpha_base\\n                 * \\u03b1_b = alpha_base * \\u03b1\\n                 * \\u03b1_c = alpha_base * \\u03b1^2\\n                 * \\u03b1_d = alpha_base * \\u03b1^3\\n                 *\\n                 * range_accumulator = (\\n                 *   D1(D1 - 1)(D1 - 2)(D1 - 3).\\u03b1_a +\\n                 *   D2(D2 - 1)(D2 - 2)(D2 - 3).\\u03b1_b +\\n                 *   D3(D3 - 1)(D3 - 2)(D3 - 3).\\u03b1_c +\\n                 *   D4(D4 - 1)(D4 - 2)(D4 - 3).\\u03b1_d +\\n                 * ) . q_sort\\n                 */\\n                let minus_two := sub(p, 2)\\n                let minus_three := sub(p, 3)\\n                let d1 := addmod(mload(W2_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                let d2 := addmod(mload(W3_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n                let d3 := addmod(mload(W4_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                let d4 := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                let range_accumulator :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(addmod(mulmod(d1, d1, p), sub(p, d1), p), addmod(d1, minus_two, p), p),\\n                            addmod(d1, minus_three, p),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d2, d2, p), sub(p, d2), p), addmod(d2, minus_two, p), p),\\n                                addmod(d2, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d3, d3, p), sub(p, d3), p), addmod(d3, minus_two, p), p),\\n                                addmod(d3, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d4, d4, p), sub(p, d4), p), addmod(d4, minus_two, p), p),\\n                                addmod(d4, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator := mulmod(range_accumulator, mload(QSORT_EVAL_LOC), p)\\n\\n                mstore(SORT_IDENTITY, range_accumulator)\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ELLIPTIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * endo_term = (-x_2) * x_1 * (x_3 * 2 + x_1) * q_beta\\n                 * endo_sqr_term = x_2^2\\n                 * endo_sqr_term *= (x_3 - x_1)\\n                 * endo_sqr_term *= q_beta^2\\n                 * leftovers = x_2^2\\n                 * leftovers *= x_2\\n                 * leftovers += x_1^2 * (x_3 + x_1) @follow-up Invalid comment in BB widget\\n                 * leftovers -= (y_2^2 + y_1^2)\\n                 * sign_term = y_2 * y_1\\n                 * sign_term += sign_term\\n                 * sign_term *= q_sign\\n                 */\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let x_diff := addmod(mload(X2_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p)\\n                let y2_sqr := mulmod(mload(Y2_EVAL_LOC), mload(Y2_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let y1y2 := mulmod(mulmod(mload(Y1_EVAL_LOC), mload(Y2_EVAL_LOC), p), mload(QSIGN_LOC), p)\\n\\n                let x_add_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X2_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            mulmod(x_diff, x_diff, p),\\n                            p\\n                        ),\\n                        addmod(\\n                            sub(\\n                                p,\\n                                addmod(y2_sqr, y1_sqr, p)\\n                            ),\\n                            addmod(y1y2, y1y2, p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                x_add_identity :=\\n                    mulmod(\\n                        mulmod(\\n                            x_add_identity,\\n                            addmod(\\n                                1,\\n                                sub(p, mload(QM_EVAL_LOC)),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let y1_plus_y3 := addmod(\\n                    mload(Y1_EVAL_LOC),\\n                    mload(Y3_EVAL_LOC),\\n                    p\\n                )\\n                let y_diff := addmod(mulmod(mload(Y2_EVAL_LOC), mload(QSIGN_LOC), p), sub(p, mload(Y1_EVAL_LOC)), p)\\n                let y_add_identity :=\\n                    addmod(\\n                        mulmod(y1_plus_y3, x_diff, p),\\n                        mulmod(addmod(mload(X3_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p), y_diff, p),\\n                        p\\n                    )\\n                y_add_identity :=\\n                    mulmod(\\n                        mulmod(y_add_identity, addmod(1, sub(p, mload(QM_EVAL_LOC)), p), p),\\n                        mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                        p\\n                    )\\n\\n                // ELLIPTIC_IDENTITY = (x_identity + y_identity) * Q_ELLIPTIC_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY, mulmod(addmod(x_add_identity, y_add_identity, p), mload(QELLIPTIC_EVAL_LOC), p)\\n                )\\n            }\\n            {\\n                /**\\n                 * x_pow_4 = (y_1_sqr - curve_b) * x_1;\\n                 * y_1_sqr_mul_4 = y_1_sqr + y_1_sqr;\\n                 * y_1_sqr_mul_4 += y_1_sqr_mul_4;\\n                 * x_1_pow_4_mul_9 = x_pow_4;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_pow_4;\\n                 * x_1_sqr_mul_3 = x_1_sqr + x_1_sqr + x_1_sqr;\\n                 * x_double_identity = (x_3 + x_1 + x_1) * y_1_sqr_mul_4 - x_1_pow_4_mul_9;\\n                 * y_double_identity = x_1_sqr_mul_3 * (x_1 - x_3) - (y_1 + y_1) * (y_1 + y_3);\\n                 */\\n                // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n                let x1_sqr := mulmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let x_pow_4 := mulmod(addmod(y1_sqr, GRUMPKIN_CURVE_B_PARAMETER_NEGATED, p), mload(X1_EVAL_LOC), p)\\n                let y1_sqr_mul_4 := mulmod(y1_sqr, 4, p)\\n                let x1_pow_4_mul_9 := mulmod(x_pow_4, 9, p)\\n                let x1_sqr_mul_3 := mulmod(x1_sqr, 3, p)\\n                let x_double_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            y1_sqr_mul_4,\\n                            p\\n                        ),\\n                        sub(p, x1_pow_4_mul_9),\\n                        p\\n                    )\\n                // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n                let y_double_identity :=\\n                    addmod(\\n                        mulmod(x1_sqr_mul_3, addmod(mload(X1_EVAL_LOC), sub(p, mload(X3_EVAL_LOC)), p), p),\\n                        sub(\\n                            p,\\n                            mulmod(\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p),\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y3_EVAL_LOC), p),\\n                                p\\n                            )\\n                        ),\\n                        p\\n                    )\\n                x_double_identity := mulmod(x_double_identity, mload(C_ALPHA_BASE_LOC), p)\\n                y_double_identity :=\\n                    mulmod(y_double_identity, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p), p)\\n                x_double_identity := mulmod(x_double_identity, mload(QM_EVAL_LOC), p)\\n                y_double_identity := mulmod(y_double_identity, mload(QM_EVAL_LOC), p)\\n                // ELLIPTIC_IDENTITY += (x_double_identity + y_double_identity) * Q_DOUBLE_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY,\\n                    addmod(\\n                        mload(ELLIPTIC_IDENTITY),\\n                        mulmod(addmod(x_double_identity, y_double_identity, p), mload(QELLIPTIC_EVAL_LOC), p),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE AUXILIARY WIDGET EVALUATION\\n             */\\n            {\\n                {\\n                    /**\\n                     * Non native field arithmetic gate 2\\n                     *             _                                                                               _\\n                     *            /   _                   _                               _       14                \\\\\\n                     * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n                     *            \\\\_                                                                               _/\\n                     *\\n                     * limb_subproduct = w_1 . w_2_omega + w_1_omega . w_2\\n                     * non_native_field_gate_2 = w_1 * w_4 + w_4 * w_3 - w_3_omega\\n                     * non_native_field_gate_2 = non_native_field_gate_2 * limb_size\\n                     * non_native_field_gate_2 -= w_4_omega\\n                     * non_native_field_gate_2 += limb_subproduct\\n                     * non_native_field_gate_2 *= q_4\\n                     * limb_subproduct *= limb_size\\n                     * limb_subproduct += w_1_omega * w_2_omega\\n                     * non_native_field_gate_1 = (limb_subproduct + w_3 + w_4) * q_3\\n                     * non_native_field_gate_3 = (limb_subproduct + w_4 - (w_3_omega + w_4_omega)) * q_m\\n                     * non_native_field_identity = (non_native_field_gate_1 + non_native_field_gate_2 + non_native_field_gate_3) * q_2\\n                     */\\n\\n                    let limb_subproduct :=\\n                        addmod(\\n                            mulmod(mload(W1_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\\n                            mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_EVAL_LOC), p),\\n                            p\\n                        )\\n\\n                    let non_native_field_gate_2 :=\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p),\\n                                mulmod(mload(W2_EVAL_LOC), mload(W3_EVAL_LOC), p),\\n                                p\\n                            ),\\n                            sub(p, mload(W3_OMEGA_EVAL_LOC)),\\n                            p\\n                        )\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, LIMB_SIZE, p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, limb_subproduct, p)\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, mload(Q4_EVAL_LOC), p)\\n                    limb_subproduct := mulmod(limb_subproduct, LIMB_SIZE, p)\\n                    limb_subproduct :=\\n                        addmod(limb_subproduct, mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p)\\n                    let non_native_field_gate_1 :=\\n                        mulmod(\\n                            addmod(limb_subproduct, sub(p, addmod(mload(W3_EVAL_LOC), mload(W4_EVAL_LOC), p)), p),\\n                            mload(Q3_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_gate_3 :=\\n                        mulmod(\\n                            addmod(\\n                                addmod(limb_subproduct, mload(W4_EVAL_LOC), p),\\n                                sub(p, addmod(mload(W3_OMEGA_EVAL_LOC), mload(W4_OMEGA_EVAL_LOC), p)),\\n                                p\\n                            ),\\n                            mload(QM_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_identity :=\\n                        mulmod(\\n                            addmod(addmod(non_native_field_gate_1, non_native_field_gate_2, p), non_native_field_gate_3, p),\\n                            mload(Q2_EVAL_LOC),\\n                            p\\n                        )\\n\\n                    mstore(AUX_NON_NATIVE_FIELD_EVALUATION, non_native_field_identity)\\n                }\\n\\n                {\\n                    /**\\n                     * limb_accumulator_1 = w_2_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_3;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_2;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1;\\n                     * limb_accumulator_1 -= w_4;\\n                     * limb_accumulator_1 *= q_4;\\n                     */\\n                    let limb_accumulator_1 := mulmod(mload(W2_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W2_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_EVAL_LOC), p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, sub(p, mload(W4_EVAL_LOC)), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, mload(Q4_EVAL_LOC), p)\\n\\n                    /**\\n                     * limb_accumulator_2 = w_3_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_2_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_1_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_4;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_3;\\n                     * limb_accumulator_2 -= w_4_omega;\\n                     * limb_accumulator_2 *= q_m;\\n                     */\\n                    let limb_accumulator_2 := mulmod(mload(W3_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W2_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W4_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, mload(QM_EVAL_LOC), p)\\n\\n                    mstore(\\n                        AUX_LIMB_ACCUMULATOR_EVALUATION,\\n                        mulmod(addmod(limb_accumulator_1, limb_accumulator_2, p), mload(Q3_EVAL_LOC), p)\\n                    )\\n                }\\n\\n                {\\n                    /**\\n                     * memory_record_check = w_3;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_2;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_1;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += q_c;\\n                     *\\n                     * partial_record_check = memory_record_check;\\n                     *\\n                     * memory_record_check -= w_4;\\n                     */\\n\\n                    let memory_record_check := mulmod(mload(W3_EVAL_LOC), mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W2_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W1_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(QC_EVAL_LOC), p)\\n\\n                    let partial_record_check := memory_record_check\\n                    memory_record_check := addmod(memory_record_check, sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                    mstore(AUX_MEMORY_EVALUATION, memory_record_check)\\n\\n                    // index_delta = w_1_omega - w_1\\n                    let index_delta := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                    // record_delta = w_4_omega - w_4\\n                    let record_delta := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n                    // index_is_monotonically_increasing = index_delta * (index_delta - 1)\\n                    let index_is_monotonically_increasing := mulmod(index_delta, addmod(index_delta, sub(p, 1), p), p)\\n\\n                    // adjacent_values_match_if_adjacent_indices_match = record_delta * (1 - index_delta)\\n                    let adjacent_values_match_if_adjacent_indices_match :=\\n                        mulmod(record_delta, addmod(1, sub(p, index_delta), p), p)\\n\\n                    // AUX_ROM_CONSISTENCY_EVALUATION = ((adjacent_values_match_if_adjacent_indices_match * alpha) + index_is_monotonically_increasing) * alpha + partial_record_check\\n                    mstore(\\n                        AUX_ROM_CONSISTENCY_EVALUATION,\\n                        addmod(\\n                            mulmod(\\n                                addmod(\\n                                    mulmod(adjacent_values_match_if_adjacent_indices_match, mload(C_ALPHA_LOC), p),\\n                                    index_is_monotonically_increasing,\\n                                    p\\n                                ),\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            ),\\n                            memory_record_check,\\n                            p\\n                        )\\n                    )\\n\\n                    {\\n                        /**\\n                         * next_gate_access_type = w_3_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_2_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_1_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type = w_4_omega - next_gate_access_type;\\n                         */\\n                        let next_gate_access_type := mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W2_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W1_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, next_gate_access_type), p)\\n\\n                        // value_delta = w_3_omega - w_3\\n                        let value_delta := addmod(mload(W3_OMEGA_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                        //  adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (1 - index_delta) * value_delta * (1 - next_gate_access_type);\\n\\n                        let adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation :=\\n                            mulmod(\\n                                addmod(1, sub(p, index_delta), p),\\n                                mulmod(value_delta, addmod(1, sub(p, next_gate_access_type), p), p),\\n                                p\\n                            )\\n\\n                        // AUX_RAM_CONSISTENCY_EVALUATION\\n\\n                        /**\\n                         * access_type = w_4 - partial_record_check\\n                         * access_check = access_type^2 - access_type\\n                         * next_gate_access_type_is_boolean = next_gate_access_type^2 - next_gate_access_type\\n                         * RAM_consistency_check_identity = adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += index_is_monotonically_increasing;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += next_gate_access_type_is_boolean;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += access_check;\\n                         */\\n\\n                        let access_type := addmod(mload(W4_EVAL_LOC), sub(p, partial_record_check), p)\\n                        let access_check := mulmod(access_type, addmod(access_type, sub(p, 1), p), p)\\n                        let next_gate_access_type_is_boolean :=\\n                            mulmod(next_gate_access_type, addmod(next_gate_access_type, sub(p, 1), p), p)\\n                        let RAM_cci :=\\n                            mulmod(\\n                                adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation,\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            )\\n                        RAM_cci := addmod(RAM_cci, index_is_monotonically_increasing, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, next_gate_access_type_is_boolean, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, access_check, p)\\n\\n                        mstore(AUX_RAM_CONSISTENCY_EVALUATION, RAM_cci)\\n                    }\\n\\n                    {\\n                        // timestamp_delta = w_2_omega - w_2\\n                        let timestamp_delta := addmod(mload(W2_OMEGA_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n\\n                        // RAM_timestamp_check_identity = (1 - index_delta) * timestamp_delta - w_3\\n                        let RAM_timestamp_check_identity :=\\n                            addmod(\\n                                mulmod(timestamp_delta, addmod(1, sub(p, index_delta), p), p), sub(p, mload(W3_EVAL_LOC)), p\\n                            )\\n\\n                        /**\\n                         * memory_identity = ROM_consistency_check_identity * q_2;\\n                         * memory_identity += RAM_timestamp_check_identity * q_4;\\n                         * memory_identity += memory_record_check * q_m;\\n                         * memory_identity *= q_1;\\n                         * memory_identity += (RAM_consistency_check_identity * q_arith);\\n                         *\\n                         * auxiliary_identity = memory_identity + non_native_field_identity + limb_accumulator_identity;\\n                         * auxiliary_identity *= q_aux;\\n                         * auxiliary_identity *= alpha_base;\\n                         */\\n                        let memory_identity := mulmod(mload(AUX_ROM_CONSISTENCY_EVALUATION), mload(Q2_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(RAM_timestamp_check_identity, mload(Q4_EVAL_LOC), p), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(mload(AUX_MEMORY_EVALUATION), mload(QM_EVAL_LOC), p), p)\\n                        memory_identity := mulmod(memory_identity, mload(Q1_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(\\n                                memory_identity, mulmod(mload(AUX_RAM_CONSISTENCY_EVALUATION), mload(QARITH_EVAL_LOC), p), p\\n                            )\\n\\n                        let auxiliary_identity := addmod(memory_identity, mload(AUX_NON_NATIVE_FIELD_EVALUATION), p)\\n                        auxiliary_identity := addmod(auxiliary_identity, mload(AUX_LIMB_ACCUMULATOR_EVALUATION), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(QAUX_EVAL_LOC), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(C_ALPHA_BASE_LOC), p)\\n\\n                        mstore(AUX_IDENTITY, auxiliary_identity)\\n\\n                        // update alpha\\n                        mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * quotient = ARITHMETIC_IDENTITY\\n                 * quotient += PERMUTATION_IDENTITY\\n                 * quotient += PLOOKUP_IDENTITY\\n                 * quotient += SORT_IDENTITY\\n                 * quotient += ELLIPTIC_IDENTITY\\n                 * quotient += AUX_IDENTITY\\n                 * quotient *= ZERO_POLY_INVERSE\\n                 */\\n                mstore(\\n                    QUOTIENT_EVAL_LOC,\\n                    mulmod(\\n                        addmod(\\n                            addmod(\\n                                addmod(\\n                                    addmod(\\n                                        addmod(mload(PERMUTATION_IDENTITY), mload(PLOOKUP_IDENTITY), p),\\n                                        mload(ARITHMETIC_IDENTITY),\\n                                        p\\n                                    ),\\n                                    mload(SORT_IDENTITY),\\n                                    p\\n                                ),\\n                                mload(ELLIPTIC_IDENTITY),\\n                                p\\n                            ),\\n                            mload(AUX_IDENTITY),\\n                            p\\n                        ),\\n                        mload(ZERO_POLY_INVERSE_LOC),\\n                        p\\n                    )\\n                )\\n            }\\n\\n            /**\\n             * GENERATE NU AND SEPARATOR CHALLENGES\\n             */\\n            {\\n                let current_challenge := mload(C_CURRENT_LOC)\\n                // get a calldata pointer that points to the start of the data we want to copy\\n                let calldata_ptr := add(calldataload(0x04), 0x24)\\n\\n                calldata_ptr := add(calldata_ptr, NU_CALLDATA_SKIP_LENGTH)\\n\\n                mstore(NU_CHALLENGE_INPUT_LOC_A, current_challenge)\\n                mstore(NU_CHALLENGE_INPUT_LOC_B, mload(QUOTIENT_EVAL_LOC))\\n                calldatacopy(NU_CHALLENGE_INPUT_LOC_C, calldata_ptr, NU_INPUT_LENGTH)\\n\\n                // hash length = (0x20 + num field elements), we include the previous challenge in the hash\\n                let challenge := keccak256(NU_CHALLENGE_INPUT_LOC_A, add(NU_INPUT_LENGTH, 0x40))\\n\\n                mstore(C_V0_LOC, mod(challenge, p))\\n                // We need THIRTY-ONE independent nu challenges!\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x02)\\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x03)\\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x04)\\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x05)\\n                mstore(C_V5_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x06)\\n                mstore(C_V6_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x07)\\n                mstore(C_V7_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x08)\\n                mstore(C_V8_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x09)\\n                mstore(C_V9_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0a)\\n                mstore(C_V10_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0b)\\n                mstore(C_V11_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0c)\\n                mstore(C_V12_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0d)\\n                mstore(C_V13_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0e)\\n                mstore(C_V14_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0f)\\n                mstore(C_V15_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x10)\\n                mstore(C_V16_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x11)\\n                mstore(C_V17_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x12)\\n                mstore(C_V18_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x13)\\n                mstore(C_V19_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x14)\\n                mstore(C_V20_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x15)\\n                mstore(C_V21_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x16)\\n                mstore(C_V22_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x17)\\n                mstore(C_V23_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x18)\\n                mstore(C_V24_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x19)\\n                mstore(C_V25_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1a)\\n                mstore(C_V26_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1b)\\n                mstore(C_V27_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1c)\\n                mstore(C_V28_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1d)\\n                mstore(C_V29_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                // @follow-up - Why are both v29 and v30 using appending 0x1d to the prior challenge and hashing, should it not change?\\n                mstore8(0x20, 0x1d)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_V30_LOC, mod(challenge, p))\\n\\n                // separator\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\\n\\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\\n            }\\n\\n            let success := 0\\n            // VALIDATE T1\\n            {\\n                let x := mload(T1_X_LOC)\\n                let y := mload(T1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                mstore(ACCUMULATOR_X_LOC, x)\\n                mstore(add(ACCUMULATOR_X_LOC, 0x20), y)\\n            }\\n            // VALIDATE T2\\n            {\\n                let x := mload(T2_X_LOC) // 0x1400\\n                let y := mload(T2_Y_LOC) // 0x1420\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(ZETA_POW_N_LOC))\\n            // accumulator_2 = [T2].zeta^n\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = [T1] + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T3\\n            {\\n                let x := mload(T3_X_LOC)\\n                let y := mload(T3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T3].zeta^{2n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T4\\n            {\\n                let x := mload(T4_X_LOC)\\n                let y := mload(T4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T4].zeta^{3n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W1\\n            {\\n                let x := mload(W1_X_LOC)\\n                let y := mload(W1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V0_LOC), p))\\n            // accumulator_2 = v0.(u + 1).[W1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W2\\n            {\\n                let x := mload(W2_X_LOC)\\n                let y := mload(W2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V1_LOC), p))\\n            // accumulator_2 = v1.(u + 1).[W2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W3\\n            {\\n                let x := mload(W3_X_LOC)\\n                let y := mload(W3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V2_LOC), p))\\n            // accumulator_2 = v2.(u + 1).[W3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W4\\n            {\\n                let x := mload(W4_X_LOC)\\n                let y := mload(W4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V3_LOC), p))\\n            // accumulator_2 = v3.(u + 1).[W4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE S\\n            {\\n                let x := mload(S_X_LOC)\\n                let y := mload(S_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V4_LOC), p))\\n            // accumulator_2 = v4.(u + 1).[S]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z\\n            {\\n                let x := mload(Z_X_LOC)\\n                let y := mload(Z_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V5_LOC), p))\\n            // accumulator_2 = v5.(u + 1).[Z]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z_LOOKUP\\n            {\\n                let x := mload(Z_LOOKUP_X_LOC)\\n                let y := mload(Z_LOOKUP_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V6_LOC), p))\\n            // accumulator_2 = v6.(u + 1).[Z_LOOKUP]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q1\\n            {\\n                let x := mload(Q1_X_LOC)\\n                let y := mload(Q1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V7_LOC))\\n            // accumulator_2 = v7.[Q1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q2\\n            {\\n                let x := mload(Q2_X_LOC)\\n                let y := mload(Q2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V8_LOC))\\n            // accumulator_2 = v8.[Q2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q3\\n            {\\n                let x := mload(Q3_X_LOC)\\n                let y := mload(Q3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V9_LOC))\\n            // accumulator_2 = v9.[Q3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q4\\n            {\\n                let x := mload(Q4_X_LOC)\\n                let y := mload(Q4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V10_LOC))\\n            // accumulator_2 = v10.[Q4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QM\\n            {\\n                let x := mload(QM_X_LOC)\\n                let y := mload(QM_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V11_LOC))\\n            // accumulator_2 = v11.[Q;]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QC\\n            {\\n                let x := mload(QC_X_LOC)\\n                let y := mload(QC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V12_LOC))\\n            // accumulator_2 = v12.[QC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QARITH\\n            {\\n                let x := mload(QARITH_X_LOC)\\n                let y := mload(QARITH_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V13_LOC))\\n            // accumulator_2 = v13.[QARITH]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QSORT\\n            {\\n                let x := mload(QSORT_X_LOC)\\n                let y := mload(QSORT_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V14_LOC))\\n            // accumulator_2 = v14.[QSORT]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QELLIPTIC\\n            {\\n                let x := mload(QELLIPTIC_X_LOC)\\n                let y := mload(QELLIPTIC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V15_LOC))\\n            // accumulator_2 = v15.[QELLIPTIC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QAUX\\n            {\\n                let x := mload(QAUX_X_LOC)\\n                let y := mload(QAUX_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V16_LOC))\\n            // accumulator_2 = v15.[Q_AUX]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA1\\n            {\\n                let x := mload(SIGMA1_X_LOC)\\n                let y := mload(SIGMA1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V17_LOC))\\n            // accumulator_2 = v17.[sigma1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA2\\n            {\\n                let x := mload(SIGMA2_X_LOC)\\n                let y := mload(SIGMA2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V18_LOC))\\n            // accumulator_2 = v18.[sigma2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA3\\n            {\\n                let x := mload(SIGMA3_X_LOC)\\n                let y := mload(SIGMA3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V19_LOC))\\n            // accumulator_2 = v19.[sigma3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA4\\n            {\\n                let x := mload(SIGMA4_X_LOC)\\n                let y := mload(SIGMA4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V20_LOC))\\n            // accumulator_2 = v20.[sigma4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE1\\n            {\\n                let x := mload(TABLE1_X_LOC)\\n                let y := mload(TABLE1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V21_LOC), p))\\n            // accumulator_2 = u.[table1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE2\\n            {\\n                let x := mload(TABLE2_X_LOC)\\n                let y := mload(TABLE2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V22_LOC), p))\\n            // accumulator_2 = u.[table2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE3\\n            {\\n                let x := mload(TABLE3_X_LOC)\\n                let y := mload(TABLE3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V23_LOC), p))\\n            // accumulator_2 = u.[table3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE4\\n            {\\n                let x := mload(TABLE4_X_LOC)\\n                let y := mload(TABLE4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V24_LOC), p))\\n            // accumulator_2 = u.[table4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE_TYPE\\n            {\\n                let x := mload(TABLE_TYPE_X_LOC)\\n                let y := mload(TABLE_TYPE_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V25_LOC))\\n            // accumulator_2 = v25.[TableType]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID1\\n            {\\n                let x := mload(ID1_X_LOC)\\n                let y := mload(ID1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V26_LOC))\\n            // accumulator_2 = v26.[ID1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID2\\n            {\\n                let x := mload(ID2_X_LOC)\\n                let y := mload(ID2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V27_LOC))\\n            // accumulator_2 = v27.[ID2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID3\\n            {\\n                let x := mload(ID3_X_LOC)\\n                let y := mload(ID3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V28_LOC))\\n            // accumulator_2 = v28.[ID3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID4\\n            {\\n                let x := mload(ID4_X_LOC)\\n                let y := mload(ID4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V29_LOC))\\n            // accumulator_2 = v29.[ID4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            /**\\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\\n             */\\n            {\\n                /**\\n                 * batch_evaluation = v0 * (w_1_omega * u + w_1_eval)\\n                 * batch_evaluation += v1 * (w_2_omega * u + w_2_eval)\\n                 * batch_evaluation += v2 * (w_3_omega * u + w_3_eval)\\n                 * batch_evaluation += v3 * (w_4_omega * u + w_4_eval)\\n                 * batch_evaluation += v4 * (s_omega_eval * u + s_eval)\\n                 * batch_evaluation += v5 * (z_omega_eval * u + z_eval)\\n                 * batch_evaluation += v6 * (z_lookup_omega_eval * u + z_lookup_eval)\\n                 */\\n                let batch_evaluation :=\\n                    mulmod(\\n                        mload(C_V0_LOC),\\n                        addmod(mulmod(mload(W1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W1_EVAL_LOC), p),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V1_LOC),\\n                            addmod(mulmod(mload(W2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V2_LOC),\\n                            addmod(mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V3_LOC),\\n                            addmod(mulmod(mload(W4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V4_LOC),\\n                            addmod(mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(S_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V5_LOC),\\n                            addmod(mulmod(mload(Z_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V6_LOC),\\n                            addmod(mulmod(mload(Z_LOOKUP_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_LOOKUP_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                /**\\n                 * batch_evaluation += v7 * Q1_EVAL\\n                 * batch_evaluation += v8 * Q2_EVAL\\n                 * batch_evaluation += v9 * Q3_EVAL\\n                 * batch_evaluation += v10 * Q4_EVAL\\n                 * batch_evaluation += v11 * QM_EVAL\\n                 * batch_evaluation += v12 * QC_EVAL\\n                 * batch_evaluation += v13 * QARITH_EVAL\\n                 * batch_evaluation += v14 * QSORT_EVAL_LOC\\n                 * batch_evaluation += v15 * QELLIPTIC_EVAL_LOC\\n                 * batch_evaluation += v16 * QAUX_EVAL_LOC\\n                 * batch_evaluation += v17 * SIGMA1_EVAL_LOC\\n                 * batch_evaluation += v18 * SIGMA2_EVAL_LOC\\n                 * batch_evaluation += v19 * SIGMA3_EVAL_LOC\\n                 * batch_evaluation += v20 * SIGMA4_EVAL_LOC\\n                 */\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V7_LOC), mload(Q1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V8_LOC), mload(Q2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V9_LOC), mload(Q3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V10_LOC), mload(Q4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V11_LOC), mload(QM_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V12_LOC), mload(QC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V13_LOC), mload(QARITH_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V14_LOC), mload(QSORT_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V15_LOC), mload(QELLIPTIC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V16_LOC), mload(QAUX_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V17_LOC), mload(SIGMA1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V18_LOC), mload(SIGMA2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V19_LOC), mload(SIGMA3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V20_LOC), mload(SIGMA4_EVAL_LOC), p), p)\\n\\n                /**\\n                 * batch_evaluation += v21 * (table1(zw) * u + table1(z))\\n                 * batch_evaluation += v22 * (table2(zw) * u + table2(z))\\n                 * batch_evaluation += v23 * (table3(zw) * u + table3(z))\\n                 * batch_evaluation += v24 * (table4(zw) * u + table4(z))\\n                 * batch_evaluation += v25 * table_type_eval\\n                 * batch_evaluation += v26 * id1_eval\\n                 * batch_evaluation += v27 * id2_eval\\n                 * batch_evaluation += v28 * id3_eval\\n                 * batch_evaluation += v29 * id4_eval\\n                 * batch_evaluation += quotient_eval\\n                 */\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V21_LOC),\\n                            addmod(mulmod(mload(TABLE1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE1_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V22_LOC),\\n                            addmod(mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V23_LOC),\\n                            addmod(mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V24_LOC),\\n                            addmod(mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V25_LOC), mload(TABLE_TYPE_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V26_LOC), mload(ID1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V27_LOC), mload(ID2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V28_LOC), mload(ID3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V29_LOC), mload(ID4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mload(QUOTIENT_EVAL_LOC), p)\\n\\n                mstore(0x00, 0x01) // [1].x\\n                mstore(0x20, 0x02) // [1].y\\n                mstore(0x40, sub(p, batch_evaluation))\\n                // accumulator_2 = -[1].(batch_evaluation)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                mstore(OPENING_COMMITMENT_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING PREAMBLE\\n             */\\n            {\\n                let u := mload(C_U_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                // VALIDATE PI_Z\\n                {\\n                    let x := mload(PI_Z_X_LOC)\\n                    let y := mload(PI_Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(0x40, zeta)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                // VALIDATE PI_Z_OMEGA\\n                {\\n                    let x := mload(PI_Z_OMEGA_X_LOC)\\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\\n                // accumulator_2 = u.zeta.omega.[PI_Z_OMEGA]\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // PAIRING_RHS = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                mstore(0x00, mload(PI_Z_X_LOC))\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, u)\\n                success := and(success, staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40))\\n                // PAIRING_LHS = [PI_Z] + [PI_Z_OMEGA] * u\\n                success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                // negate lhs y-coordinate\\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\\n\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    // VALIDATE RECURSIVE P1\\n                    {\\n                        let x := mload(RECURSIVE_P1_X_LOC)\\n                        let y := mload(RECURSIVE_P1_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n\\n                    // compute u.u.[recursive_p1] and write into 0x60\\n                    mstore(0x40, mulmod(u, u, p))\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\\n                    // VALIDATE RECURSIVE P2\\n                    {\\n                        let x := mload(RECURSIVE_P2_X_LOC)\\n                        let y := mload(RECURSIVE_P2_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n                    // compute u.u.[recursive_p2] and write into 0x00\\n                    // 0x40 still contains u*u\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\\n\\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                }\\n\\n                if iszero(success) {\\n                    mstore(0x0, EC_SCALAR_MUL_FAILURE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(PAIRING_PREAMBLE_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING\\n             */\\n            {\\n                // rhs paired with [1]_2\\n                // lhs paired with [x]_2\\n\\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\\n\\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\\n                mstore(0x100, mload(G2X_X0_LOC))\\n                mstore(0x120, mload(G2X_X1_LOC))\\n                mstore(0x140, mload(G2X_Y0_LOC))\\n                mstore(0x160, mload(G2X_Y1_LOC))\\n\\n                success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\\n                mstore(PAIRING_SUCCESS_FLAG, success)\\n                mstore(RESULT_FLAG, mload(0x00))\\n            }\\n            if iszero(\\n                and(\\n                    and(and(mload(PAIRING_SUCCESS_FLAG), mload(RESULT_FLAG)), mload(PAIRING_PREAMBLE_SUCCESS_FLAG)),\\n                    mload(OPENING_COMMITMENT_SUCCESS_FLAG)\\n                )\\n            ) {\\n                mstore(0x0, PROOF_FAILURE_SELECTOR)\\n                revert(0x00, 0x04)\\n            }\\n            {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20) // Proof succeeded!\\n            }\\n        }\\n    }\\n}\\n\\ncontract PasskeyUltraVerifier is PasskeyBaseUltraVerifier {\\n    function getVerificationKeyHash() public pure override(PasskeyBaseUltraVerifier) returns (bytes32) {\\n        return PasskeyUltraVerificationKey.verificationKeyHash();\\n    }\\n\\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual override(PasskeyBaseUltraVerifier) {\\n        PasskeyUltraVerificationKey.loadVerificationKey(vk, _omegaInverseLoc);\\n    }\\n}\\n\",\"keccak256\":\"0xbbcb5772c128e333191203d6fd4d41ba914966cae83bcfe8791489f4f49ee00d\",\"license\":\"Apache-2.0\"},\"contracts/verifier/RecoveryVerifier.sol\":{\"content\":\"// Verification Key Hash: e13c3f3318307b11b77f1a74e69ae66a27df3023102a7ee9d634af3849efa63e\\n// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.4;\\n\\nlibrary RecoveryUltraVerificationKey {\\n    function verificationKeyHash() internal pure returns(bytes32) {\\n        return 0xe13c3f3318307b11b77f1a74e69ae66a27df3023102a7ee9d634af3849efa63e;\\n    }\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure {\\n        assembly {\\n            mstore(add(_vk, 0x00), 0x0000000000000000000000000000000000000000000000000000000000010000) // vk.circuit_size\\n            mstore(add(_vk, 0x20), 0x0000000000000000000000000000000000000000000000000000000000000040) // vk.num_inputs\\n            mstore(add(_vk, 0x40), 0x00eeb2cb5981ed45649abebde081dcff16c8601de4347e7dd1628ba2daac43b7) // vk.work_root\\n            mstore(add(_vk, 0x60), 0x30641e0e92bebef818268d663bcad6dbcfd6c0149170f6d7d350b1b1fa6c1001) // vk.domain_inverse\\n            mstore(add(_vk, 0x80), 0x113fa8017bcda6b360e6c979e87bd5cfb36cb98938a113fbc7f3bfa2d7aabdb3) // vk.Q1.x\\n            mstore(add(_vk, 0xa0), 0x0ca2cbe16379df7a343750cede22e6eac4c9d91b4d7f101b89840e935d1b54c6) // vk.Q1.y\\n            mstore(add(_vk, 0xc0), 0x01707233bb3400424c97ffb2ab2e1be170b9c0f071e0cd3ea1f6c150ad527a1d) // vk.Q2.x\\n            mstore(add(_vk, 0xe0), 0x060e5b5f5d97af4d51a77017d00ef59f0ec901d46b9133c55b8b2ceac266e2cc) // vk.Q2.y\\n            mstore(add(_vk, 0x100), 0x05d7c554cfecf7a7bc17259b9cba4217cdf56ce0fe455fa486533ceb400b561d) // vk.Q3.x\\n            mstore(add(_vk, 0x120), 0x1eaa34dd55d04b2c259b2ad1674a7b313de4151596061974bda0360e2ad615d9) // vk.Q3.y\\n            mstore(add(_vk, 0x140), 0x2860c8a1cdc10097aee70cd4f38ecee210eb5841ea2e37ecac879350acb934aa) // vk.Q4.x\\n            mstore(add(_vk, 0x160), 0x139dac0231b8d0c1b4bf2bfa2be09361269686de71575f10bf24ab60c4b1a9c1) // vk.Q4.y\\n            mstore(add(_vk, 0x180), 0x0e78b39b94af964a220af5377cdc81a3cf72c8cfada639d1037eda3ad4af4a8f) // vk.Q_M.x\\n            mstore(add(_vk, 0x1a0), 0x239e46ff59c830e3d050dc14b22b3d6e34a486e39fc1279baf8a37f1229d4abf) // vk.Q_M.y\\n            mstore(add(_vk, 0x1c0), 0x18d9d5878cb96a680313461c815f1bf987d09aceace51abcd356196ac8f8772d) // vk.Q_C.x\\n            mstore(add(_vk, 0x1e0), 0x07ea08e08c90582bb944863c5dcb29264c83a6d9f94952a9fe4e38c820a7b7e3) // vk.Q_C.y\\n            mstore(add(_vk, 0x200), 0x1a6fdedaba36b941d180a82cb9e8dfef3eaba86509db76de84ad7fe6a8199579) // vk.Q_ARITHMETIC.x\\n            mstore(add(_vk, 0x220), 0x1cd8e49bc5b88cdaf03503b37ae9a41c9f75d2651c396a1b31e4426786a843d2) // vk.Q_ARITHMETIC.y\\n            mstore(add(_vk, 0x240), 0x1f9f4f66c0b2f548358c5ca165f99ff0f0bb9c6f8a65d6bd46c67ac579d07866) // vk.QSORT.x\\n            mstore(add(_vk, 0x260), 0x23e99e39847469785faf758ef7a1a4a365e8f726ef6cbbbb4873eb149bfbd5e1) // vk.QSORT.y\\n            mstore(add(_vk, 0x280), 0x21245d6c0a4d2ff12b21a825f39f30e8f8cf9b259448d111183e975828539576) // vk.Q_ELLIPTIC.x\\n            mstore(add(_vk, 0x2a0), 0x16a409532c8a1693536e93b6ce9920bfc2e6796e8dfe404675a0cdf6ee77ee7a) // vk.Q_ELLIPTIC.y\\n            mstore(add(_vk, 0x2c0), 0x1cd1c349b92c30c05be5a1ee7e67a744e8bb7109663119ea1dde206eeb6fae88) // vk.Q_AUX.x\\n            mstore(add(_vk, 0x2e0), 0x1b47d5e6bfc15897c3239296a7071ea69d582cf14a51df88c721f45944cfa66b) // vk.Q_AUX.y\\n            mstore(add(_vk, 0x300), 0x2e4cae94b8a613ba8d9a9968f49f148a240992ca3ed59ab767364c86eb826e7c) // vk.SIGMA1.x\\n            mstore(add(_vk, 0x320), 0x122a44607ca19f6954c5596f8674a6d069bb85c4a889370f4f9b5c8b1718d717) // vk.SIGMA1.y\\n            mstore(add(_vk, 0x340), 0x0a129b8e8946fd2e15477abceaa3e3505db239c38c1b6dda753ad176e30372ef) // vk.SIGMA2.x\\n            mstore(add(_vk, 0x360), 0x0eaf12fadcfec19916f32c8cbf90949cc398de3a6fc84c0a03df6c5f2451612d) // vk.SIGMA2.y\\n            mstore(add(_vk, 0x380), 0x0dde4795aabb389e47762c32219021a6a8f5e75352c590c198e6ad4e9af014c9) // vk.SIGMA3.x\\n            mstore(add(_vk, 0x3a0), 0x2b1ed2643043fbb6eb7feddfcb5c15031f4f8f5838f47575c5a68d28a98e3927) // vk.SIGMA3.y\\n            mstore(add(_vk, 0x3c0), 0x20374ba486fb22e6b3a928c48d2bb333a9f19c4544ab799b349608bf7b8eb683) // vk.SIGMA4.x\\n            mstore(add(_vk, 0x3e0), 0x2c030687fbbbcc2372918e037faacd89d111e8a32a0f503f4831c7ac6deabd53) // vk.SIGMA4.y\\n            mstore(add(_vk, 0x400), 0x2d7b48cbc49369ed1cde65148e2498e140f966468dcef75af4d67f31816afd18) // vk.TABLE1.x\\n            mstore(add(_vk, 0x420), 0x135f08c76c4ed7d4e8a393191e74ba47656da1bb0896597cc1a6448fed2b7c1d) // vk.TABLE1.y\\n            mstore(add(_vk, 0x440), 0x1b2b5303108f39b1b60de7e5bba14d680d749e5a47b1b8da408e43e6b1526c53) // vk.TABLE2.x\\n            mstore(add(_vk, 0x460), 0x004c2cd9885a252c47ead21c8493e53888f839749df6de13fa1dab972a051b38) // vk.TABLE2.y\\n            mstore(add(_vk, 0x480), 0x1e9aac567b0e9aa97d3f5d3663899bb8fd1bcdbe2592be1247aa03493f2981c0) // vk.TABLE3.x\\n            mstore(add(_vk, 0x4a0), 0x0995b2fd14ae0cbc20dfab371a2f40f7e7d5f7849e9039779a46a68256fe590f) // vk.TABLE3.y\\n            mstore(add(_vk, 0x4c0), 0x2e3f9578be253b84d848ebadc3b0e6fd02f975095eb7a1f79c18d1f396d60585) // vk.TABLE4.x\\n            mstore(add(_vk, 0x4e0), 0x10d59ba05b111138f930f6d2dd0ec2fa7650060f43263bc280ffda41f4ba66aa) // vk.TABLE4.y\\n            mstore(add(_vk, 0x500), 0x1e98d51ae6d9ac8b54b10d05e21672157439c39cd9c60f9238eb6e4bb55ba83d) // vk.TABLE_TYPE.x\\n            mstore(add(_vk, 0x520), 0x077eeb9cbd3d39a75e2a015385a71d9f9bee7a7e4a96725916a1040d6e4fb99f) // vk.TABLE_TYPE.y\\n            mstore(add(_vk, 0x540), 0x28f8b4f783647e7e1a17e79c7ffdf4edc385e5ce97490494300782bbd8fa0ac2) // vk.ID1.x\\n            mstore(add(_vk, 0x560), 0x2f8eb2a694c7b2472074406502faec0fc7383b3908d6eda641fa4dd9ffafd8da) // vk.ID1.y\\n            mstore(add(_vk, 0x580), 0x12ad964422406b87ef2e597c8c1cb9af759c39df5b50fcdb458c0ff79c61741e) // vk.ID2.x\\n            mstore(add(_vk, 0x5a0), 0x06d2e6ea5272f320df19b52bc72956186b310307619f7c03c19c1019c985ce7d) // vk.ID2.y\\n            mstore(add(_vk, 0x5c0), 0x0568c820c1e5a06918f83075ced691f3bc14854a3763e6e4d4d4e211fe5d39de) // vk.ID3.x\\n            mstore(add(_vk, 0x5e0), 0x2636c246030445d794291bf275d391ca10a6807c1cc2ff97624e7f6b71908e8d) // vk.ID3.y\\n            mstore(add(_vk, 0x600), 0x06c2201e8a40ba1e781967f0ae5ae8377e7fa93f5af4971a7c4f65a91a022682) // vk.ID4.x\\n            mstore(add(_vk, 0x620), 0x2199e56e074ead004a049aeff570336079e54d84b58160534ddfd60bd849d858) // vk.ID4.y\\n            mstore(add(_vk, 0x640), 0x00) // vk.contains_recursive_proof\\n            mstore(add(_vk, 0x660), 0) // vk.recursive_proof_public_input_indices\\n            mstore(add(_vk, 0x680), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1 \\n            mstore(add(_vk, 0x6a0), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0 \\n            mstore(add(_vk, 0x6c0), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1 \\n            mstore(add(_vk, 0x6e0), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0 \\n            mstore(_omegaInverseLoc, 0x0b5d56b77fe704e8e92338c0082f37e091126414c830e4c6922d5ac802d842d4) // vk.work_root_inverse\\n        }\\n    }\\n}\\n/**\\n * @title Ultra Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n */\\nabstract contract RecoveryBaseUltraVerifier {\\n    // VERIFICATION KEY MEMORY LOCATIONS\\n    uint256 internal constant N_LOC = 0x380;\\n    uint256 internal constant NUM_INPUTS_LOC = 0x3a0;\\n    uint256 internal constant OMEGA_LOC = 0x3c0;\\n    uint256 internal constant DOMAIN_INVERSE_LOC = 0x3e0;\\n    uint256 internal constant Q1_X_LOC = 0x400;\\n    uint256 internal constant Q1_Y_LOC = 0x420;\\n    uint256 internal constant Q2_X_LOC = 0x440;\\n    uint256 internal constant Q2_Y_LOC = 0x460;\\n    uint256 internal constant Q3_X_LOC = 0x480;\\n    uint256 internal constant Q3_Y_LOC = 0x4a0;\\n    uint256 internal constant Q4_X_LOC = 0x4c0;\\n    uint256 internal constant Q4_Y_LOC = 0x4e0;\\n    uint256 internal constant QM_X_LOC = 0x500;\\n    uint256 internal constant QM_Y_LOC = 0x520;\\n    uint256 internal constant QC_X_LOC = 0x540;\\n    uint256 internal constant QC_Y_LOC = 0x560;\\n    uint256 internal constant QARITH_X_LOC = 0x580;\\n    uint256 internal constant QARITH_Y_LOC = 0x5a0;\\n    uint256 internal constant QSORT_X_LOC = 0x5c0;\\n    uint256 internal constant QSORT_Y_LOC = 0x5e0;\\n    uint256 internal constant QELLIPTIC_X_LOC = 0x600;\\n    uint256 internal constant QELLIPTIC_Y_LOC = 0x620;\\n    uint256 internal constant QAUX_X_LOC = 0x640;\\n    uint256 internal constant QAUX_Y_LOC = 0x660;\\n    uint256 internal constant SIGMA1_X_LOC = 0x680;\\n    uint256 internal constant SIGMA1_Y_LOC = 0x6a0;\\n    uint256 internal constant SIGMA2_X_LOC = 0x6c0;\\n    uint256 internal constant SIGMA2_Y_LOC = 0x6e0;\\n    uint256 internal constant SIGMA3_X_LOC = 0x700;\\n    uint256 internal constant SIGMA3_Y_LOC = 0x720;\\n    uint256 internal constant SIGMA4_X_LOC = 0x740;\\n    uint256 internal constant SIGMA4_Y_LOC = 0x760;\\n    uint256 internal constant TABLE1_X_LOC = 0x780;\\n    uint256 internal constant TABLE1_Y_LOC = 0x7a0;\\n    uint256 internal constant TABLE2_X_LOC = 0x7c0;\\n    uint256 internal constant TABLE2_Y_LOC = 0x7e0;\\n    uint256 internal constant TABLE3_X_LOC = 0x800;\\n    uint256 internal constant TABLE3_Y_LOC = 0x820;\\n    uint256 internal constant TABLE4_X_LOC = 0x840;\\n    uint256 internal constant TABLE4_Y_LOC = 0x860;\\n    uint256 internal constant TABLE_TYPE_X_LOC = 0x880;\\n    uint256 internal constant TABLE_TYPE_Y_LOC = 0x8a0;\\n    uint256 internal constant ID1_X_LOC = 0x8c0;\\n    uint256 internal constant ID1_Y_LOC = 0x8e0;\\n    uint256 internal constant ID2_X_LOC = 0x900;\\n    uint256 internal constant ID2_Y_LOC = 0x920;\\n    uint256 internal constant ID3_X_LOC = 0x940;\\n    uint256 internal constant ID3_Y_LOC = 0x960;\\n    uint256 internal constant ID4_X_LOC = 0x980;\\n    uint256 internal constant ID4_Y_LOC = 0x9a0;\\n    uint256 internal constant CONTAINS_RECURSIVE_PROOF_LOC = 0x9c0;\\n    uint256 internal constant RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC = 0x9e0;\\n    uint256 internal constant G2X_X0_LOC = 0xa00;\\n    uint256 internal constant G2X_X1_LOC = 0xa20;\\n    uint256 internal constant G2X_Y0_LOC = 0xa40;\\n    uint256 internal constant G2X_Y1_LOC = 0xa60;\\n\\n    // ### PROOF DATA MEMORY LOCATIONS\\n    uint256 internal constant W1_X_LOC = 0x1200;\\n    uint256 internal constant W1_Y_LOC = 0x1220;\\n    uint256 internal constant W2_X_LOC = 0x1240;\\n    uint256 internal constant W2_Y_LOC = 0x1260;\\n    uint256 internal constant W3_X_LOC = 0x1280;\\n    uint256 internal constant W3_Y_LOC = 0x12a0;\\n    uint256 internal constant W4_X_LOC = 0x12c0;\\n    uint256 internal constant W4_Y_LOC = 0x12e0;\\n    uint256 internal constant S_X_LOC = 0x1300;\\n    uint256 internal constant S_Y_LOC = 0x1320;\\n    uint256 internal constant Z_X_LOC = 0x1340;\\n    uint256 internal constant Z_Y_LOC = 0x1360;\\n    uint256 internal constant Z_LOOKUP_X_LOC = 0x1380;\\n    uint256 internal constant Z_LOOKUP_Y_LOC = 0x13a0;\\n    uint256 internal constant T1_X_LOC = 0x13c0;\\n    uint256 internal constant T1_Y_LOC = 0x13e0;\\n    uint256 internal constant T2_X_LOC = 0x1400;\\n    uint256 internal constant T2_Y_LOC = 0x1420;\\n    uint256 internal constant T3_X_LOC = 0x1440;\\n    uint256 internal constant T3_Y_LOC = 0x1460;\\n    uint256 internal constant T4_X_LOC = 0x1480;\\n    uint256 internal constant T4_Y_LOC = 0x14a0;\\n\\n    uint256 internal constant W1_EVAL_LOC = 0x1600;\\n    uint256 internal constant W2_EVAL_LOC = 0x1620;\\n    uint256 internal constant W3_EVAL_LOC = 0x1640;\\n    uint256 internal constant W4_EVAL_LOC = 0x1660;\\n    uint256 internal constant S_EVAL_LOC = 0x1680;\\n    uint256 internal constant Z_EVAL_LOC = 0x16a0;\\n    uint256 internal constant Z_LOOKUP_EVAL_LOC = 0x16c0;\\n    uint256 internal constant Q1_EVAL_LOC = 0x16e0;\\n    uint256 internal constant Q2_EVAL_LOC = 0x1700;\\n    uint256 internal constant Q3_EVAL_LOC = 0x1720;\\n    uint256 internal constant Q4_EVAL_LOC = 0x1740;\\n    uint256 internal constant QM_EVAL_LOC = 0x1760;\\n    uint256 internal constant QC_EVAL_LOC = 0x1780;\\n    uint256 internal constant QARITH_EVAL_LOC = 0x17a0;\\n    uint256 internal constant QSORT_EVAL_LOC = 0x17c0;\\n    uint256 internal constant QELLIPTIC_EVAL_LOC = 0x17e0;\\n    uint256 internal constant QAUX_EVAL_LOC = 0x1800;\\n    uint256 internal constant TABLE1_EVAL_LOC = 0x1840;\\n    uint256 internal constant TABLE2_EVAL_LOC = 0x1860;\\n    uint256 internal constant TABLE3_EVAL_LOC = 0x1880;\\n    uint256 internal constant TABLE4_EVAL_LOC = 0x18a0;\\n    uint256 internal constant TABLE_TYPE_EVAL_LOC = 0x18c0;\\n    uint256 internal constant ID1_EVAL_LOC = 0x18e0;\\n    uint256 internal constant ID2_EVAL_LOC = 0x1900;\\n    uint256 internal constant ID3_EVAL_LOC = 0x1920;\\n    uint256 internal constant ID4_EVAL_LOC = 0x1940;\\n    uint256 internal constant SIGMA1_EVAL_LOC = 0x1960;\\n    uint256 internal constant SIGMA2_EVAL_LOC = 0x1980;\\n    uint256 internal constant SIGMA3_EVAL_LOC = 0x19a0;\\n    uint256 internal constant SIGMA4_EVAL_LOC = 0x19c0;\\n    uint256 internal constant W1_OMEGA_EVAL_LOC = 0x19e0;\\n    uint256 internal constant W2_OMEGA_EVAL_LOC = 0x2000;\\n    uint256 internal constant W3_OMEGA_EVAL_LOC = 0x2020;\\n    uint256 internal constant W4_OMEGA_EVAL_LOC = 0x2040;\\n    uint256 internal constant S_OMEGA_EVAL_LOC = 0x2060;\\n    uint256 internal constant Z_OMEGA_EVAL_LOC = 0x2080;\\n    uint256 internal constant Z_LOOKUP_OMEGA_EVAL_LOC = 0x20a0;\\n    uint256 internal constant TABLE1_OMEGA_EVAL_LOC = 0x20c0;\\n    uint256 internal constant TABLE2_OMEGA_EVAL_LOC = 0x20e0;\\n    uint256 internal constant TABLE3_OMEGA_EVAL_LOC = 0x2100;\\n    uint256 internal constant TABLE4_OMEGA_EVAL_LOC = 0x2120;\\n\\n    uint256 internal constant PI_Z_X_LOC = 0x2300;\\n    uint256 internal constant PI_Z_Y_LOC = 0x2320;\\n    uint256 internal constant PI_Z_OMEGA_X_LOC = 0x2340;\\n    uint256 internal constant PI_Z_OMEGA_Y_LOC = 0x2360;\\n\\n    // Used for elliptic widget. These are alias names for wire + shifted wire evaluations\\n    uint256 internal constant X1_EVAL_LOC = W2_EVAL_LOC;\\n    uint256 internal constant X2_EVAL_LOC = W1_OMEGA_EVAL_LOC;\\n    uint256 internal constant X3_EVAL_LOC = W2_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y1_EVAL_LOC = W3_EVAL_LOC;\\n    uint256 internal constant Y2_EVAL_LOC = W4_OMEGA_EVAL_LOC;\\n    uint256 internal constant Y3_EVAL_LOC = W3_OMEGA_EVAL_LOC;\\n    uint256 internal constant QBETA_LOC = Q3_EVAL_LOC;\\n    uint256 internal constant QBETA_SQR_LOC = Q4_EVAL_LOC;\\n    uint256 internal constant QSIGN_LOC = Q1_EVAL_LOC;\\n\\n    // ### CHALLENGES MEMORY OFFSETS\\n\\n    uint256 internal constant C_BETA_LOC = 0x2600;\\n    uint256 internal constant C_GAMMA_LOC = 0x2620;\\n    uint256 internal constant C_ALPHA_LOC = 0x2640;\\n    uint256 internal constant C_ETA_LOC = 0x2660;\\n    uint256 internal constant C_ETA_SQR_LOC = 0x2680;\\n    uint256 internal constant C_ETA_CUBE_LOC = 0x26a0;\\n\\n    uint256 internal constant C_ZETA_LOC = 0x26c0;\\n    uint256 internal constant C_CURRENT_LOC = 0x26e0;\\n    uint256 internal constant C_V0_LOC = 0x2700;\\n    uint256 internal constant C_V1_LOC = 0x2720;\\n    uint256 internal constant C_V2_LOC = 0x2740;\\n    uint256 internal constant C_V3_LOC = 0x2760;\\n    uint256 internal constant C_V4_LOC = 0x2780;\\n    uint256 internal constant C_V5_LOC = 0x27a0;\\n    uint256 internal constant C_V6_LOC = 0x27c0;\\n    uint256 internal constant C_V7_LOC = 0x27e0;\\n    uint256 internal constant C_V8_LOC = 0x2800;\\n    uint256 internal constant C_V9_LOC = 0x2820;\\n    uint256 internal constant C_V10_LOC = 0x2840;\\n    uint256 internal constant C_V11_LOC = 0x2860;\\n    uint256 internal constant C_V12_LOC = 0x2880;\\n    uint256 internal constant C_V13_LOC = 0x28a0;\\n    uint256 internal constant C_V14_LOC = 0x28c0;\\n    uint256 internal constant C_V15_LOC = 0x28e0;\\n    uint256 internal constant C_V16_LOC = 0x2900;\\n    uint256 internal constant C_V17_LOC = 0x2920;\\n    uint256 internal constant C_V18_LOC = 0x2940;\\n    uint256 internal constant C_V19_LOC = 0x2960;\\n    uint256 internal constant C_V20_LOC = 0x2980;\\n    uint256 internal constant C_V21_LOC = 0x29a0;\\n    uint256 internal constant C_V22_LOC = 0x29c0;\\n    uint256 internal constant C_V23_LOC = 0x29e0;\\n    uint256 internal constant C_V24_LOC = 0x2a00;\\n    uint256 internal constant C_V25_LOC = 0x2a20;\\n    uint256 internal constant C_V26_LOC = 0x2a40;\\n    uint256 internal constant C_V27_LOC = 0x2a60;\\n    uint256 internal constant C_V28_LOC = 0x2a80;\\n    uint256 internal constant C_V29_LOC = 0x2aa0;\\n    uint256 internal constant C_V30_LOC = 0x2ac0;\\n\\n    uint256 internal constant C_U_LOC = 0x2b00;\\n\\n    // ### LOCAL VARIABLES MEMORY OFFSETS\\n    uint256 internal constant DELTA_NUMERATOR_LOC = 0x3000;\\n    uint256 internal constant DELTA_DENOMINATOR_LOC = 0x3020;\\n    uint256 internal constant ZETA_POW_N_LOC = 0x3040;\\n    uint256 internal constant PUBLIC_INPUT_DELTA_LOC = 0x3060;\\n    uint256 internal constant ZERO_POLY_LOC = 0x3080;\\n    uint256 internal constant L_START_LOC = 0x30a0;\\n    uint256 internal constant L_END_LOC = 0x30c0;\\n    uint256 internal constant R_ZERO_EVAL_LOC = 0x30e0;\\n\\n    uint256 internal constant PLOOKUP_DELTA_NUMERATOR_LOC = 0x3100;\\n    uint256 internal constant PLOOKUP_DELTA_DENOMINATOR_LOC = 0x3120;\\n    uint256 internal constant PLOOKUP_DELTA_LOC = 0x3140;\\n\\n    uint256 internal constant ACCUMULATOR_X_LOC = 0x3160;\\n    uint256 internal constant ACCUMULATOR_Y_LOC = 0x3180;\\n    uint256 internal constant ACCUMULATOR2_X_LOC = 0x31a0;\\n    uint256 internal constant ACCUMULATOR2_Y_LOC = 0x31c0;\\n    uint256 internal constant PAIRING_LHS_X_LOC = 0x31e0;\\n    uint256 internal constant PAIRING_LHS_Y_LOC = 0x3200;\\n    uint256 internal constant PAIRING_RHS_X_LOC = 0x3220;\\n    uint256 internal constant PAIRING_RHS_Y_LOC = 0x3240;\\n\\n    // ### SUCCESS FLAG MEMORY LOCATIONS\\n    uint256 internal constant GRAND_PRODUCT_SUCCESS_FLAG = 0x3300;\\n    uint256 internal constant ARITHMETIC_TERM_SUCCESS_FLAG = 0x3020;\\n    uint256 internal constant BATCH_OPENING_SUCCESS_FLAG = 0x3340;\\n    uint256 internal constant OPENING_COMMITMENT_SUCCESS_FLAG = 0x3360;\\n    uint256 internal constant PAIRING_PREAMBLE_SUCCESS_FLAG = 0x3380;\\n    uint256 internal constant PAIRING_SUCCESS_FLAG = 0x33a0;\\n    uint256 internal constant RESULT_FLAG = 0x33c0;\\n\\n    // misc stuff\\n    uint256 internal constant OMEGA_INVERSE_LOC = 0x3400;\\n    uint256 internal constant C_ALPHA_SQR_LOC = 0x3420;\\n    uint256 internal constant C_ALPHA_CUBE_LOC = 0x3440;\\n    uint256 internal constant C_ALPHA_QUAD_LOC = 0x3460;\\n    uint256 internal constant C_ALPHA_BASE_LOC = 0x3480;\\n\\n    // ### RECURSION VARIABLE MEMORY LOCATIONS\\n    uint256 internal constant RECURSIVE_P1_X_LOC = 0x3500;\\n    uint256 internal constant RECURSIVE_P1_Y_LOC = 0x3520;\\n    uint256 internal constant RECURSIVE_P2_X_LOC = 0x3540;\\n    uint256 internal constant RECURSIVE_P2_Y_LOC = 0x3560;\\n\\n    uint256 internal constant PUBLIC_INPUTS_HASH_LOCATION = 0x3580;\\n\\n    // sub-identity storage\\n    uint256 internal constant PERMUTATION_IDENTITY = 0x3600;\\n    uint256 internal constant PLOOKUP_IDENTITY = 0x3620;\\n    uint256 internal constant ARITHMETIC_IDENTITY = 0x3640;\\n    uint256 internal constant SORT_IDENTITY = 0x3660;\\n    uint256 internal constant ELLIPTIC_IDENTITY = 0x3680;\\n    uint256 internal constant AUX_IDENTITY = 0x36a0;\\n    uint256 internal constant AUX_NON_NATIVE_FIELD_EVALUATION = 0x36c0;\\n    uint256 internal constant AUX_LIMB_ACCUMULATOR_EVALUATION = 0x36e0;\\n    uint256 internal constant AUX_RAM_CONSISTENCY_EVALUATION = 0x3700;\\n    uint256 internal constant AUX_ROM_CONSISTENCY_EVALUATION = 0x3720;\\n    uint256 internal constant AUX_MEMORY_EVALUATION = 0x3740;\\n\\n    uint256 internal constant QUOTIENT_EVAL_LOC = 0x3760;\\n    uint256 internal constant ZERO_POLY_INVERSE_LOC = 0x3780;\\n\\n    // when hashing public inputs we use memory at NU_CHALLENGE_INPUT_LOC_A, as the hash input size is unknown at compile time\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_A = 0x37a0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_B = 0x37c0;\\n    uint256 internal constant NU_CHALLENGE_INPUT_LOC_C = 0x37e0;\\n\\n    bytes4 internal constant PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR = 0xeba9f4a6;\\n    bytes4 internal constant PUBLIC_INPUT_GE_P_SELECTOR = 0x374a972f;\\n    bytes4 internal constant MOD_EXP_FAILURE_SELECTOR = 0xf894a7bc;\\n    bytes4 internal constant EC_SCALAR_MUL_FAILURE_SELECTOR = 0xf755f369;\\n    bytes4 internal constant PROOF_FAILURE_SELECTOR = 0x0711fcec;\\n\\n    uint256 internal constant ETA_INPUT_LENGTH = 0xc0; // W1, W2, W3 = 6 * 0x20 bytes\\n\\n    // We need to hash 41 field elements when generating the NU challenge\\n    // w1, w2, w3, w4, s, z, z_lookup, q1, q2, q3, q4, qm, qc, qarith (14)\\n    // qsort, qelliptic, qaux, sigma1, sigma2, sigma, sigma4, (7)\\n    // table1, table2, table3, table4, tabletype, id1, id2, id3, id4, (9)\\n    // w1_omega, w2_omega, w3_omega, w4_omega, s_omega, z_omega, z_lookup_omega, (7)\\n    // table1_omega, table2_omega, table3_omega, table4_omega (4)\\n    uint256 internal constant NU_INPUT_LENGTH = 0x520; // 0x520 = 41 * 0x20\\n\\n    // There are ELEVEN G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n    // W1, W2, W3, W4, S, Z, Z_LOOKUP, T1, T2, T3, T4\\n    uint256 internal constant NU_CALLDATA_SKIP_LENGTH = 0x2c0; // 11 * 0x40 = 0x2c0\\n\\n    uint256 internal constant NEGATIVE_INVERSE_OF_2_MODULO_P =\\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    uint256 internal constant LIMB_SIZE = 0x100000000000000000; // 2<<68\\n    uint256 internal constant SUBLIMB_SHIFT = 0x4000; // 2<<14\\n\\n    // y^2 = x^3 + ax + b\\n    // for Grumpkin, a = 0 and b = -17. We use b in a custom gate relation that evaluates elliptic curve arithmetic\\n    uint256 internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = 17;\\n    error PUBLIC_INPUT_COUNT_INVALID(uint256 expected, uint256 actual);\\n    error PUBLIC_INPUT_INVALID_BN128_G1_POINT();\\n    error PUBLIC_INPUT_GE_P();\\n    error MOD_EXP_FAILURE();\\n    error EC_SCALAR_MUL_FAILURE();\\n    error PROOF_FAILURE();\\n\\n    function getVerificationKeyHash() public pure virtual returns (bytes32);\\n\\n    function loadVerificationKey(uint256 _vk, uint256 _omegaInverseLoc) internal pure virtual;\\n\\n    /**\\n     * @notice Verify a Ultra Plonk proof\\n     * @param _proof - The serialized proof\\n     * @param _publicInputs - An array of the public inputs\\n     * @return True if proof is valid, reverts otherwise\\n     */\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool) {\\n        loadVerificationKey(N_LOC, OMEGA_INVERSE_LOC);\\n\\n        uint256 requiredPublicInputCount;\\n        assembly {\\n            requiredPublicInputCount := mload(NUM_INPUTS_LOC)\\n        }\\n        if (requiredPublicInputCount != _publicInputs.length) {\\n            revert PUBLIC_INPUT_COUNT_INVALID(requiredPublicInputCount, _publicInputs.length);\\n        }\\n\\n        assembly {\\n            let q := 21888242871839275222246405745257275088696311157297823662689037894645226208583 // EC group order\\n            let p := 21888242871839275222246405745257275088548364400416034343698204186575808495617 // Prime field order\\n\\n            /**\\n             * LOAD PROOF FROM CALLDATA\\n             */\\n            {\\n                let data_ptr := add(calldataload(0x04), 0x24)\\n\\n                mstore(W1_Y_LOC, mod(calldataload(data_ptr), q))\\n                mstore(W1_X_LOC, mod(calldataload(add(data_ptr, 0x20)), q))\\n\\n                mstore(W2_Y_LOC, mod(calldataload(add(data_ptr, 0x40)), q))\\n                mstore(W2_X_LOC, mod(calldataload(add(data_ptr, 0x60)), q))\\n\\n                mstore(W3_Y_LOC, mod(calldataload(add(data_ptr, 0x80)), q))\\n                mstore(W3_X_LOC, mod(calldataload(add(data_ptr, 0xa0)), q))\\n\\n                mstore(W4_Y_LOC, mod(calldataload(add(data_ptr, 0xc0)), q))\\n                mstore(W4_X_LOC, mod(calldataload(add(data_ptr, 0xe0)), q))\\n\\n                mstore(S_Y_LOC, mod(calldataload(add(data_ptr, 0x100)), q))\\n                mstore(S_X_LOC, mod(calldataload(add(data_ptr, 0x120)), q))\\n                mstore(Z_Y_LOC, mod(calldataload(add(data_ptr, 0x140)), q))\\n                mstore(Z_X_LOC, mod(calldataload(add(data_ptr, 0x160)), q))\\n                mstore(Z_LOOKUP_Y_LOC, mod(calldataload(add(data_ptr, 0x180)), q))\\n                mstore(Z_LOOKUP_X_LOC, mod(calldataload(add(data_ptr, 0x1a0)), q))\\n                mstore(T1_Y_LOC, mod(calldataload(add(data_ptr, 0x1c0)), q))\\n                mstore(T1_X_LOC, mod(calldataload(add(data_ptr, 0x1e0)), q))\\n\\n                mstore(T2_Y_LOC, mod(calldataload(add(data_ptr, 0x200)), q))\\n                mstore(T2_X_LOC, mod(calldataload(add(data_ptr, 0x220)), q))\\n\\n                mstore(T3_Y_LOC, mod(calldataload(add(data_ptr, 0x240)), q))\\n                mstore(T3_X_LOC, mod(calldataload(add(data_ptr, 0x260)), q))\\n\\n                mstore(T4_Y_LOC, mod(calldataload(add(data_ptr, 0x280)), q))\\n                mstore(T4_X_LOC, mod(calldataload(add(data_ptr, 0x2a0)), q))\\n\\n                mstore(W1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2c0)), p))\\n                mstore(W2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x2e0)), p))\\n                mstore(W3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x300)), p))\\n                mstore(W4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x320)), p))\\n                mstore(S_EVAL_LOC, mod(calldataload(add(data_ptr, 0x340)), p))\\n                mstore(Z_EVAL_LOC, mod(calldataload(add(data_ptr, 0x360)), p))\\n                mstore(Z_LOOKUP_EVAL_LOC, mod(calldataload(add(data_ptr, 0x380)), p))\\n                mstore(Q1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3a0)), p))\\n                mstore(Q2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3c0)), p))\\n                mstore(Q3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x3e0)), p))\\n                mstore(Q4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x400)), p))\\n                mstore(QM_EVAL_LOC, mod(calldataload(add(data_ptr, 0x420)), p))\\n                mstore(QC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x440)), p))\\n                mstore(QARITH_EVAL_LOC, mod(calldataload(add(data_ptr, 0x460)), p))\\n                mstore(QSORT_EVAL_LOC, mod(calldataload(add(data_ptr, 0x480)), p))\\n                mstore(QELLIPTIC_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4a0)), p))\\n                mstore(QAUX_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4c0)), p))\\n\\n                mstore(SIGMA1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x4e0)), p))\\n                mstore(SIGMA2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x500)), p))\\n\\n                mstore(SIGMA3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x520)), p))\\n                mstore(SIGMA4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x540)), p))\\n\\n                mstore(TABLE1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x560)), p))\\n                mstore(TABLE2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x580)), p))\\n                mstore(TABLE3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5a0)), p))\\n                mstore(TABLE4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5c0)), p))\\n                mstore(TABLE_TYPE_EVAL_LOC, mod(calldataload(add(data_ptr, 0x5e0)), p))\\n\\n                mstore(ID1_EVAL_LOC, mod(calldataload(add(data_ptr, 0x600)), p))\\n                mstore(ID2_EVAL_LOC, mod(calldataload(add(data_ptr, 0x620)), p))\\n                mstore(ID3_EVAL_LOC, mod(calldataload(add(data_ptr, 0x640)), p))\\n                mstore(ID4_EVAL_LOC, mod(calldataload(add(data_ptr, 0x660)), p))\\n\\n                mstore(W1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x680)), p))\\n                mstore(W2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6a0)), p))\\n                mstore(W3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6c0)), p))\\n                mstore(W4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x6e0)), p))\\n                mstore(S_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x700)), p))\\n\\n                mstore(Z_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x720)), p))\\n\\n                mstore(Z_LOOKUP_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x740)), p))\\n                mstore(TABLE1_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x760)), p))\\n                mstore(TABLE2_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x780)), p))\\n                mstore(TABLE3_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7a0)), p))\\n                mstore(TABLE4_OMEGA_EVAL_LOC, mod(calldataload(add(data_ptr, 0x7c0)), p))\\n\\n                mstore(PI_Z_Y_LOC, mod(calldataload(add(data_ptr, 0x7e0)), q))\\n                mstore(PI_Z_X_LOC, mod(calldataload(add(data_ptr, 0x800)), q))\\n\\n                mstore(PI_Z_OMEGA_Y_LOC, mod(calldataload(add(data_ptr, 0x820)), q))\\n                mstore(PI_Z_OMEGA_X_LOC, mod(calldataload(add(data_ptr, 0x840)), q))\\n            }\\n\\n            /**\\n             * LOAD RECURSIVE PROOF INTO MEMORY\\n             */\\n            {\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n                    let index_counter := add(shl(5, mload(RECURSIVE_PROOF_PUBLIC_INPUT_INDICES_LOC)), public_inputs_ptr)\\n\\n                    let x0 := calldataload(index_counter)\\n                    x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                    x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                    x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                    let y0 := calldataload(add(index_counter, 0x80))\\n                    y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                    y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                    y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                    let x1 := calldataload(add(index_counter, 0x100))\\n                    x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                    x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                    x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                    let y1 := calldataload(add(index_counter, 0x180))\\n                    y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                    y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                    y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n                    mstore(RECURSIVE_P1_X_LOC, x0)\\n                    mstore(RECURSIVE_P1_Y_LOC, y0)\\n                    mstore(RECURSIVE_P2_X_LOC, x1)\\n                    mstore(RECURSIVE_P2_Y_LOC, y1)\\n\\n                    // validate these are valid bn128 G1 points\\n                    if iszero(and(and(lt(x0, q), lt(x1, q)), and(lt(y0, q), lt(y1, q)))) {\\n                        mstore(0x00, PUBLIC_INPUT_INVALID_BN128_G1_POINT_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * Generate initial challenge\\n                 */\\n                mstore(0x00, shl(224, mload(N_LOC)))\\n                mstore(0x04, shl(224, mload(NUM_INPUTS_LOC)))\\n                let challenge := keccak256(0x00, 0x08)\\n\\n                /**\\n                 * Generate eta challenge\\n                 */\\n                mstore(PUBLIC_INPUTS_HASH_LOCATION, challenge)\\n                // The public input location is stored at 0x24, we then add 0x24 to skip selector and the length of public inputs\\n                let public_inputs_start := add(calldataload(0x24), 0x24)\\n                // copy the public inputs over\\n                let public_input_size := mul(mload(NUM_INPUTS_LOC), 0x20)\\n                calldatacopy(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_inputs_start, public_input_size)\\n\\n                // copy W1, W2, W3 into challenge. Each point is 0x40 bytes, so load 0xc0 = 3 * 0x40 bytes (ETA input length)\\n                let w_start := add(calldataload(0x04), 0x24)\\n                calldatacopy(add(add(PUBLIC_INPUTS_HASH_LOCATION, 0x20), public_input_size), w_start, ETA_INPUT_LENGTH)\\n\\n                // Challenge is the old challenge + public inputs + W1, W2, W3 (0x20 + public_input_size + 0xc0)\\n                let challenge_bytes_size := add(0x20, add(public_input_size, ETA_INPUT_LENGTH))\\n\\n                challenge := keccak256(PUBLIC_INPUTS_HASH_LOCATION, challenge_bytes_size)\\n                {\\n                    let eta := mod(challenge, p)\\n                    mstore(C_ETA_LOC, eta)\\n                    mstore(C_ETA_SQR_LOC, mulmod(eta, eta, p))\\n                    mstore(C_ETA_CUBE_LOC, mulmod(mload(C_ETA_SQR_LOC), eta, p))\\n                }\\n\\n                /**\\n                 * Generate beta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(W4_Y_LOC))\\n                mstore(0x40, mload(W4_X_LOC))\\n                mstore(0x60, mload(S_Y_LOC))\\n                mstore(0x80, mload(S_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_BETA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate gamma challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_GAMMA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Generate alpha challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(Z_Y_LOC))\\n                mstore(0x40, mload(Z_X_LOC))\\n                mstore(0x60, mload(Z_LOOKUP_Y_LOC))\\n                mstore(0x80, mload(Z_LOOKUP_X_LOC))\\n                challenge := keccak256(0x00, 0xa0)\\n                mstore(C_ALPHA_LOC, mod(challenge, p))\\n\\n                /**\\n                 * Compute and store some powers of alpha for future computations\\n                 */\\n                let alpha := mload(C_ALPHA_LOC)\\n                mstore(C_ALPHA_SQR_LOC, mulmod(alpha, alpha, p))\\n                mstore(C_ALPHA_CUBE_LOC, mulmod(mload(C_ALPHA_SQR_LOC), alpha, p))\\n                mstore(C_ALPHA_QUAD_LOC, mulmod(mload(C_ALPHA_CUBE_LOC), alpha, p))\\n                mstore(C_ALPHA_BASE_LOC, alpha)\\n\\n                /**\\n                 * Generate zeta challenge\\n                 */\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(T1_Y_LOC))\\n                mstore(0x40, mload(T1_X_LOC))\\n                mstore(0x60, mload(T2_Y_LOC))\\n                mstore(0x80, mload(T2_X_LOC))\\n                mstore(0xa0, mload(T3_Y_LOC))\\n                mstore(0xc0, mload(T3_X_LOC))\\n                mstore(0xe0, mload(T4_Y_LOC))\\n                mstore(0x100, mload(T4_X_LOC))\\n\\n                challenge := keccak256(0x00, 0x120)\\n\\n                mstore(C_ZETA_LOC, mod(challenge, p))\\n                mstore(C_CURRENT_LOC, challenge)\\n            }\\n\\n            /**\\n             * EVALUATE FIELD OPERATIONS\\n             */\\n\\n            /**\\n             * COMPUTE PUBLIC INPUT DELTA\\n             * \\u0394PI = \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3(i) + \\u03b3) / \\u220f\\u1d62\\u2208\\u2113(w\\u1d62 + \\u03b2 \\u03c3'(i) + \\u03b3)\\n             */\\n            {\\n                let beta := mload(C_BETA_LOC) // \\u03b2\\n                let gamma := mload(C_GAMMA_LOC) // \\u03b3\\n                let work_root := mload(OMEGA_LOC) // \\u03c9\\n                let numerator_value := 1\\n                let denominator_value := 1\\n\\n                let p_clone := p // move p to the front of the stack\\n                let valid_inputs := true\\n\\n                // Load the starting point of the public inputs (jump over the selector and the length of public inputs [0x24])\\n                let public_inputs_ptr := add(calldataload(0x24), 0x24)\\n\\n                // endpoint_ptr = public_inputs_ptr + num_inputs * 0x20. // every public input is 0x20 bytes\\n                let endpoint_ptr := add(public_inputs_ptr, mul(mload(NUM_INPUTS_LOC), 0x20))\\n\\n                // root_1 = \\u03b2 * 0x05\\n                let root_1 := mulmod(beta, 0x05, p_clone) // k1.\\u03b2\\n                // root_2 = \\u03b2 * 0x0c\\n                let root_2 := mulmod(beta, 0x0c, p_clone)\\n                // @note 0x05 + 0x07 == 0x0c == external coset generator\\n\\n                for {} lt(public_inputs_ptr, endpoint_ptr) { public_inputs_ptr := add(public_inputs_ptr, 0x20) } {\\n                    /**\\n                     * input = public_input[i]\\n                     * valid_inputs &= input < p\\n                     * temp = input + gamma\\n                     * numerator_value *= (\\u03b2.\\u03c3(i) + w\\u1d62 + \\u03b3)  // \\u03c3(i) = 0x05.\\u03c9\\u2071\\n                     * denominator_value *= (\\u03b2.\\u03c3'(i) + w\\u1d62 + \\u03b3) // \\u03c3'(i) = 0x0c.\\u03c9\\u2071\\n                     * root_1 *= \\u03c9\\n                     * root_2 *= \\u03c9\\n                     */\\n\\n                    let input := calldataload(public_inputs_ptr)\\n                    valid_inputs := and(valid_inputs, lt(input, p_clone))\\n                    let temp := addmod(input, gamma, p_clone)\\n\\n                    numerator_value := mulmod(numerator_value, add(root_1, temp), p_clone)\\n                    denominator_value := mulmod(denominator_value, add(root_2, temp), p_clone)\\n\\n                    root_1 := mulmod(root_1, work_root, p_clone)\\n                    root_2 := mulmod(root_2, work_root, p_clone)\\n                }\\n\\n                // Revert if not all public inputs are field elements (i.e. < p)\\n                if iszero(valid_inputs) {\\n                    mstore(0x00, PUBLIC_INPUT_GE_P_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n\\n                mstore(DELTA_NUMERATOR_LOC, numerator_value)\\n                mstore(DELTA_DENOMINATOR_LOC, denominator_value)\\n            }\\n\\n            /**\\n             * Compute Plookup delta factor [\\u03b3(1 + \\u03b2)]^{n-k}\\n             * k = num roots cut out of Z_H = 4\\n             */\\n            {\\n                let delta_base := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let delta_numerator := delta_base\\n                {\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        delta_numerator := mulmod(delta_numerator, delta_numerator, p)\\n                    }\\n                }\\n                mstore(PLOOKUP_DELTA_NUMERATOR_LOC, delta_numerator)\\n\\n                let delta_denominator := mulmod(delta_base, delta_base, p)\\n                delta_denominator := mulmod(delta_denominator, delta_denominator, p)\\n                mstore(PLOOKUP_DELTA_DENOMINATOR_LOC, delta_denominator)\\n            }\\n            /**\\n             * Compute lagrange poly and vanishing poly fractions\\n             */\\n            {\\n                /**\\n                 * vanishing_numerator = zeta\\n                 * ZETA_POW_N = zeta^n\\n                 * vanishing_numerator -= 1\\n                 * accumulating_root = omega_inverse\\n                 * work_root = p - accumulating_root\\n                 * domain_inverse = domain_inverse\\n                 * vanishing_denominator = zeta + work_root\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * work_root *= accumulating_root\\n                 * vanishing_denominator *= (zeta + work_root)\\n                 * vanishing_denominator *= (zeta + (zeta + accumulating_root))\\n                 * work_root = omega\\n                 * lagrange_numerator = vanishing_numerator * domain_inverse\\n                 * l_start_denominator = zeta - 1\\n                 * accumulating_root = work_root^2\\n                 * l_end_denominator = accumulating_root^2 * work_root * zeta - 1\\n                 * Note: l_end_denominator term contains a term \\\\omega^5 to cut out 5 roots of unity from vanishing poly\\n                 */\\n\\n                let zeta := mload(C_ZETA_LOC)\\n\\n                // compute zeta^n, where n is a power of 2\\n                let vanishing_numerator := zeta\\n                {\\n                    // pow_small\\n                    let exponent := mload(N_LOC)\\n                    let count := 1\\n                    for {} lt(count, exponent) { count := add(count, count) } {\\n                        vanishing_numerator := mulmod(vanishing_numerator, vanishing_numerator, p)\\n                    }\\n                }\\n                mstore(ZETA_POW_N_LOC, vanishing_numerator)\\n                vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n\\n                let accumulating_root := mload(OMEGA_INVERSE_LOC)\\n                let work_root := sub(p, accumulating_root)\\n                let domain_inverse := mload(DOMAIN_INVERSE_LOC)\\n\\n                let vanishing_denominator := addmod(zeta, work_root, p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                work_root := mulmod(work_root, accumulating_root, p)\\n                vanishing_denominator := mulmod(vanishing_denominator, addmod(zeta, work_root, p), p)\\n                vanishing_denominator :=\\n                    mulmod(vanishing_denominator, addmod(zeta, mulmod(work_root, accumulating_root, p), p), p)\\n\\n                work_root := mload(OMEGA_LOC)\\n\\n                let lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n                let l_start_denominator := addmod(zeta, sub(p, 1), p)\\n\\n                accumulating_root := mulmod(work_root, work_root, p)\\n\\n                let l_end_denominator :=\\n                    addmod(\\n                        mulmod(mulmod(mulmod(accumulating_root, accumulating_root, p), work_root, p), zeta, p), sub(p, 1), p\\n                    )\\n\\n                /**\\n                 * Compute inversions using Montgomery's batch inversion trick\\n                 */\\n                let accumulator := mload(DELTA_DENOMINATOR_LOC)\\n                let t0 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n                let t1 := accumulator\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n                let t2 := accumulator\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n                let t3 := accumulator\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n                let t4 := accumulator\\n                {\\n                    mstore(0, 0x20)\\n                    mstore(0x20, 0x20)\\n                    mstore(0x40, 0x20)\\n                    mstore(0x60, mulmod(accumulator, l_end_denominator, p))\\n                    mstore(0x80, sub(p, 2))\\n                    mstore(0xa0, p)\\n                    if iszero(staticcall(gas(), 0x05, 0x00, 0xc0, 0x00, 0x20)) {\\n                        mstore(0x0, MOD_EXP_FAILURE_SELECTOR)\\n                        revert(0x00, 0x04)\\n                    }\\n                    accumulator := mload(0x00)\\n                }\\n\\n                t4 := mulmod(accumulator, t4, p)\\n                accumulator := mulmod(accumulator, l_end_denominator, p)\\n\\n                t3 := mulmod(accumulator, t3, p)\\n                accumulator := mulmod(accumulator, mload(PLOOKUP_DELTA_DENOMINATOR_LOC), p)\\n\\n                t2 := mulmod(accumulator, t2, p)\\n                accumulator := mulmod(accumulator, l_start_denominator, p)\\n\\n                t1 := mulmod(accumulator, t1, p)\\n                accumulator := mulmod(accumulator, vanishing_numerator, p)\\n\\n                t0 := mulmod(accumulator, t0, p)\\n                accumulator := mulmod(accumulator, vanishing_denominator, p)\\n\\n                accumulator := mulmod(mulmod(accumulator, accumulator, p), mload(DELTA_DENOMINATOR_LOC), p)\\n\\n                mstore(PUBLIC_INPUT_DELTA_LOC, mulmod(mload(DELTA_NUMERATOR_LOC), accumulator, p))\\n                mstore(ZERO_POLY_LOC, mulmod(vanishing_numerator, t0, p))\\n                mstore(ZERO_POLY_INVERSE_LOC, mulmod(vanishing_denominator, t1, p))\\n                mstore(L_START_LOC, mulmod(lagrange_numerator, t2, p))\\n                mstore(PLOOKUP_DELTA_LOC, mulmod(mload(PLOOKUP_DELTA_NUMERATOR_LOC), t3, p))\\n                mstore(L_END_LOC, mulmod(lagrange_numerator, t4, p))\\n            }\\n\\n            /**\\n             * UltraPlonk Widget Ordering:\\n             *\\n             * 1. Permutation widget\\n             * 2. Plookup widget\\n             * 3. Arithmetic widget\\n             * 4. Fixed base widget (?)\\n             * 5. GenPermSort widget\\n             * 6. Elliptic widget\\n             * 7. Auxiliary widget\\n             */\\n\\n            /**\\n             * COMPUTE PERMUTATION WIDGET EVALUATION\\n             */\\n            {\\n                let alpha := mload(C_ALPHA_LOC)\\n                let beta := mload(C_BETA_LOC)\\n                let gamma := mload(C_GAMMA_LOC)\\n\\n                /**\\n                 * t1 = (W1 + gamma + beta * ID1) * (W2 + gamma + beta * ID2)\\n                 * t2 = (W3 + gamma + beta * ID3) * (W4 + gamma + beta * ID4)\\n                 * result = alpha_base * z_eval * t1 * t2\\n                 * t1 = (W1 + gamma + beta * sigma_1_eval) * (W2 + gamma + beta * sigma_2_eval)\\n                 * t2 = (W2 + gamma + beta * sigma_3_eval) * (W3 + gamma + beta * sigma_4_eval)\\n                 * result -= (alpha_base * z_omega_eval * t1 * t2)\\n                 */\\n                let t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(ID1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(ID2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(ID3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(ID4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                let result := mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_EVAL_LOC), mulmod(t1, t2, p), p), p)\\n                t1 :=\\n                    mulmod(\\n                        add(add(mload(W1_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA1_EVAL_LOC), p)),\\n                        add(add(mload(W2_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA2_EVAL_LOC), p)),\\n                        p\\n                    )\\n                t2 :=\\n                    mulmod(\\n                        add(add(mload(W3_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA3_EVAL_LOC), p)),\\n                        add(add(mload(W4_EVAL_LOC), gamma), mulmod(beta, mload(SIGMA4_EVAL_LOC), p)),\\n                        p\\n                    )\\n                result :=\\n                    addmod(\\n                        result,\\n                        sub(p, mulmod(mload(C_ALPHA_BASE_LOC), mulmod(mload(Z_OMEGA_EVAL_LOC), mulmod(t1, t2, p), p), p)),\\n                        p\\n                    )\\n\\n                /**\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_{n-k}(\\u0293) . (z(\\u0293.\\u03c9) - \\u2206_{PI}))\\n                 * alpha_base *= alpha\\n                 * result += alpha_base . (L_1(\\u0293)(Z(\\u0293) - 1))\\n                 * alpha_Base *= alpha\\n                 */\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                result :=\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(\\n                                mload(L_END_LOC),\\n                                addmod(mload(Z_OMEGA_EVAL_LOC), sub(p, mload(PUBLIC_INPUT_DELTA_LOC)), p),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n                mstore(\\n                    PERMUTATION_IDENTITY,\\n                    addmod(\\n                        result,\\n                        mulmod(\\n                            mload(C_ALPHA_BASE_LOC),\\n                            mulmod(mload(L_START_LOC), addmod(mload(Z_EVAL_LOC), sub(p, 1), p), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE PLOOKUP WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * Goal: f = (w1(z) + q2.w1(z\\u03c9)) + \\u03b7(w2(z) + qm.w2(z\\u03c9)) + \\u03b7\\u00b2(w3(z) + qc.w_3(z\\u03c9)) + q3(z).\\u03b7\\u00b3\\n                 * f = \\u03b7.q3(z)\\n                 * f += (w3(z) + qc.w_3(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w2(z) + qm.w2(z\\u03c9))\\n                 * f *= \\u03b7\\n                 * f += (w1(z) + q2.w1(z\\u03c9))\\n                 */\\n                let f := mulmod(mload(C_ETA_LOC), mload(Q3_EVAL_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W3_EVAL_LOC), mulmod(mload(QC_EVAL_LOC), mload(W3_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W2_EVAL_LOC), mulmod(mload(QM_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p), p)\\n                f := mulmod(f, mload(C_ETA_LOC), p)\\n                f :=\\n                    addmod(f, addmod(mload(W1_EVAL_LOC), mulmod(mload(Q2_EVAL_LOC), mload(W1_OMEGA_EVAL_LOC), p), p), p)\\n\\n                // t(z) = table4(z).\\u03b7\\u00b3 + table3(z).\\u03b7\\u00b2 + table2(z).\\u03b7 + table1(z)\\n                let t :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_EVAL_LOC),\\n                        p\\n                    )\\n\\n                // t(zw) = table4(zw).\\u03b7\\u00b3 + table3(zw).\\u03b7\\u00b2 + table2(zw).\\u03b7 + table1(zw)\\n                let t_omega :=\\n                    addmod(\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_ETA_CUBE_LOC), p),\\n                                mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_ETA_SQR_LOC), p),\\n                                p\\n                            ),\\n                            mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p),\\n                            p\\n                        ),\\n                        mload(TABLE1_OMEGA_EVAL_LOC),\\n                        p\\n                    )\\n\\n                /**\\n                 * Goal: numerator = (TABLE_TYPE_EVAL * f(z) + \\u03b3) * (t(z) + \\u03b2t(z\\u03c9) + \\u03b3(\\u03b2 + 1)) * (\\u03b2 + 1)\\n                 * gamma_beta_constant = \\u03b3(\\u03b2 + 1)\\n                 * numerator = f * TABLE_TYPE_EVAL + gamma\\n                 * temp0 = t(z) + t(z\\u03c9) * \\u03b2 + gamma_beta_constant\\n                 * numerator *= temp0\\n                 * numerator *= (\\u03b2 + 1)\\n                 * temp0 = alpha * l_1\\n                 * numerator += temp0\\n                 * numerator *= z_lookup(z)\\n                 * numerator -= temp0\\n                 */\\n                let gamma_beta_constant := mulmod(mload(C_GAMMA_LOC), addmod(mload(C_BETA_LOC), 1, p), p)\\n                let numerator := addmod(mulmod(f, mload(TABLE_TYPE_EVAL_LOC), p), mload(C_GAMMA_LOC), p)\\n                let temp0 := addmod(addmod(t, mulmod(t_omega, mload(C_BETA_LOC), p), p), gamma_beta_constant, p)\\n                numerator := mulmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, addmod(mload(C_BETA_LOC), 1, p), p)\\n                temp0 := mulmod(mload(C_ALPHA_LOC), mload(L_START_LOC), p)\\n                numerator := addmod(numerator, temp0, p)\\n                numerator := mulmod(numerator, mload(Z_LOOKUP_EVAL_LOC), p)\\n                numerator := addmod(numerator, sub(p, temp0), p)\\n\\n                /**\\n                 * Goal: denominator = z_lookup(z\\u03c9)*[s(z) + \\u03b2s(z\\u03c9) + \\u03b3(1 + \\u03b2)] - [z_lookup(z\\u03c9) - [\\u03b3(1 + \\u03b2)]^{n-k}]*\\u03b1\\u00b2L_end(z)\\n                 * note: delta_factor = [\\u03b3(1 + \\u03b2)]^{n-k}\\n                 * denominator = s(z) + \\u03b2s(z\\u03c9) + \\u03b3(\\u03b2 + 1)\\n                 * temp1 = \\u03b1\\u00b2L_end(z)\\n                 * denominator -= temp1\\n                 * denominator *= z_lookup(z\\u03c9)\\n                 * denominator += temp1 * delta_factor\\n                 * PLOOKUP_IDENTITY = (numerator - denominator).alpha_base\\n                 * alpha_base *= alpha^3\\n                 */\\n                let denominator :=\\n                    addmod(\\n                        addmod(mload(S_EVAL_LOC), mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_BETA_LOC), p), p),\\n                        gamma_beta_constant,\\n                        p\\n                    )\\n                let temp1 := mulmod(mload(C_ALPHA_SQR_LOC), mload(L_END_LOC), p)\\n                denominator := addmod(denominator, sub(p, temp1), p)\\n                denominator := mulmod(denominator, mload(Z_LOOKUP_OMEGA_EVAL_LOC), p)\\n                denominator := addmod(denominator, mulmod(temp1, mload(PLOOKUP_DELTA_LOC), p), p)\\n\\n                mstore(PLOOKUP_IDENTITY, mulmod(addmod(numerator, sub(p, denominator), p), mload(C_ALPHA_BASE_LOC), p))\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ARITHMETIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * The basic arithmetic gate identity in standard plonk is as follows.\\n                 * (w_1 . w_2 . q_m) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c = 0\\n                 * However, for Ultraplonk, we extend this to support \\\"passing\\\" wires between rows (shown without alpha scaling below):\\n                 * q_arith * ( ( (-1/2) * (q_arith - 3) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c ) +\\n                 * (q_arith - 1)*( \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m) + w_4_omega) ) = 0\\n                 *\\n                 * This formula results in several cases depending on q_arith:\\n                 * 1. q_arith == 0: Arithmetic gate is completely disabled\\n                 *\\n                 * 2. q_arith == 1: Everything in the minigate on the right is disabled. The equation is just a standard plonk equation\\n                 * with extra wires: q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c = 0\\n                 *\\n                 * 3. q_arith == 2: The (w_1 + w_4 - ...) term is disabled. THe equation is:\\n                 * (1/2) * q_m * w_1 * w_2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + w_4_omega = 0\\n                 * It allows defining w_4 at next index (w_4_omega) in terms of current wire values\\n                 *\\n                 * 4. q_arith == 3: The product of w_1 and w_2 is disabled, but a mini addition gate is enabled. \\u03b1 allows us to split\\n                 * the equation into two:\\n                 *\\n                 * q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + 2 * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0  (we are reusing q_m here)\\n                 *\\n                 * 5. q_arith > 3: The product of w_1 and w_2 is scaled by (q_arith - 3), while the w_4_omega term is scaled by (q_arith - 1).\\n                 * The equation can be split into two:\\n                 *\\n                 * (q_arith - 3)* q_m * w_1 * w_ 2 + q_1 * w_1 + q_2 * w_2 + q_3 * w_3 + q_4 * w_4 + q_c + (q_arith - 1) * w_4_omega = 0\\n                 * and\\n                 * w_1 + w_4 - w_1_omega + q_m = 0\\n                 *\\n                 * The problem that q_m is used both in both equations can be dealt with by appropriately changing selector values at\\n                 * the next gate. Then we can treat (q_arith - 1) as a simulated q_6 selector and scale q_m to handle (q_arith - 3) at\\n                 * product.\\n                 */\\n\\n                let w1q1 := mulmod(mload(W1_EVAL_LOC), mload(Q1_EVAL_LOC), p)\\n                let w2q2 := mulmod(mload(W2_EVAL_LOC), mload(Q2_EVAL_LOC), p)\\n                let w3q3 := mulmod(mload(W3_EVAL_LOC), mload(Q3_EVAL_LOC), p)\\n                let w4q3 := mulmod(mload(W4_EVAL_LOC), mload(Q4_EVAL_LOC), p)\\n\\n                // @todo - Add a explicit test that hits QARITH == 3\\n                // w1w2qm := (w_1 . w_2 . q_m . (QARITH_EVAL_LOC - 3)) / 2\\n                let w1w2qm :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(mulmod(mload(W1_EVAL_LOC), mload(W2_EVAL_LOC), p), mload(QM_EVAL_LOC), p),\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 3), p),\\n                            p\\n                        ),\\n                        NEGATIVE_INVERSE_OF_2_MODULO_P,\\n                        p\\n                    )\\n\\n                // (w_1 . w_2 . q_m . (q_arith - 3)) / -2) + (w_1 . q_1) + (w_2 . q_2) + (w_3 . q_3) + (w_4 . q_4) + q_c\\n                let identity :=\\n                    addmod(\\n                        mload(QC_EVAL_LOC), addmod(w4q3, addmod(w3q3, addmod(w2q2, addmod(w1q1, w1w2qm, p), p), p), p), p\\n                    )\\n\\n                // if q_arith == 3 we evaluate an additional mini addition gate (on top of the regular one), where:\\n                // w_1 + w_4 - w_1_omega + q_m = 0\\n                // we use this gate to save an addition gate when adding or subtracting non-native field elements\\n                // \\u03b1 * (q_arith - 2) * (w_1 + w_4 - w_1_omega + q_m)\\n                let extra_small_addition_gate_identity :=\\n                    mulmod(\\n                        mload(C_ALPHA_LOC),\\n                        mulmod(\\n                            addmod(mload(QARITH_EVAL_LOC), sub(p, 2), p),\\n                            addmod(\\n                                mload(QM_EVAL_LOC),\\n                                addmod(\\n                                    sub(p, mload(W1_OMEGA_EVAL_LOC)), addmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p), p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                // if q_arith == 2 OR q_arith == 3 we add the 4th wire of the NEXT gate into the arithmetic identity\\n                // N.B. if q_arith > 2, this wire value will be scaled by (q_arith - 1) relative to the other gate wires!\\n                // alpha_base * q_arith * (identity + (q_arith - 1) * (w_4_omega + extra_small_addition_gate_identity))\\n                mstore(\\n                    ARITHMETIC_IDENTITY,\\n                    mulmod(\\n                        mload(C_ALPHA_BASE_LOC),\\n                        mulmod(\\n                            mload(QARITH_EVAL_LOC),\\n                            addmod(\\n                                identity,\\n                                mulmod(\\n                                    addmod(mload(QARITH_EVAL_LOC), sub(p, 1), p),\\n                                    addmod(mload(W4_OMEGA_EVAL_LOC), extra_small_addition_gate_identity, p),\\n                                    p\\n                                ),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE GENPERMSORT WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * D1 = (w2 - w1)\\n                 * D2 = (w3 - w2)\\n                 * D3 = (w4 - w3)\\n                 * D4 = (w1_omega - w4)\\n                 *\\n                 * \\u03b1_a = alpha_base\\n                 * \\u03b1_b = alpha_base * \\u03b1\\n                 * \\u03b1_c = alpha_base * \\u03b1^2\\n                 * \\u03b1_d = alpha_base * \\u03b1^3\\n                 *\\n                 * range_accumulator = (\\n                 *   D1(D1 - 1)(D1 - 2)(D1 - 3).\\u03b1_a +\\n                 *   D2(D2 - 1)(D2 - 2)(D2 - 3).\\u03b1_b +\\n                 *   D3(D3 - 1)(D3 - 2)(D3 - 3).\\u03b1_c +\\n                 *   D4(D4 - 1)(D4 - 2)(D4 - 3).\\u03b1_d +\\n                 * ) . q_sort\\n                 */\\n                let minus_two := sub(p, 2)\\n                let minus_three := sub(p, 3)\\n                let d1 := addmod(mload(W2_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                let d2 := addmod(mload(W3_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n                let d3 := addmod(mload(W4_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                let d4 := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                let range_accumulator :=\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(addmod(mulmod(d1, d1, p), sub(p, d1), p), addmod(d1, minus_two, p), p),\\n                            addmod(d1, minus_three, p),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d2, d2, p), sub(p, d2), p), addmod(d2, minus_two, p), p),\\n                                addmod(d2, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d3, d3, p), sub(p, d3), p), addmod(d3, minus_two, p), p),\\n                                addmod(d3, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_SQR_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator :=\\n                    addmod(\\n                        range_accumulator,\\n                        mulmod(\\n                            mulmod(\\n                                mulmod(addmod(mulmod(d4, d4, p), sub(p, d4), p), addmod(d4, minus_two, p), p),\\n                                addmod(d4, minus_three, p),\\n                                p\\n                            ),\\n                            mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                range_accumulator := mulmod(range_accumulator, mload(QSORT_EVAL_LOC), p)\\n\\n                mstore(SORT_IDENTITY, range_accumulator)\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE ELLIPTIC WIDGET EVALUATION\\n             */\\n            {\\n                /**\\n                 * endo_term = (-x_2) * x_1 * (x_3 * 2 + x_1) * q_beta\\n                 * endo_sqr_term = x_2^2\\n                 * endo_sqr_term *= (x_3 - x_1)\\n                 * endo_sqr_term *= q_beta^2\\n                 * leftovers = x_2^2\\n                 * leftovers *= x_2\\n                 * leftovers += x_1^2 * (x_3 + x_1) @follow-up Invalid comment in BB widget\\n                 * leftovers -= (y_2^2 + y_1^2)\\n                 * sign_term = y_2 * y_1\\n                 * sign_term += sign_term\\n                 * sign_term *= q_sign\\n                 */\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let x_diff := addmod(mload(X2_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p)\\n                let y2_sqr := mulmod(mload(Y2_EVAL_LOC), mload(Y2_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let y1y2 := mulmod(mulmod(mload(Y1_EVAL_LOC), mload(Y2_EVAL_LOC), p), mload(QSIGN_LOC), p)\\n\\n                let x_add_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X2_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            mulmod(x_diff, x_diff, p),\\n                            p\\n                        ),\\n                        addmod(\\n                            sub(\\n                                p,\\n                                addmod(y2_sqr, y1_sqr, p)\\n                            ),\\n                            addmod(y1y2, y1y2, p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                x_add_identity :=\\n                    mulmod(\\n                        mulmod(\\n                            x_add_identity,\\n                            addmod(\\n                                1,\\n                                sub(p, mload(QM_EVAL_LOC)),\\n                                p\\n                            ),\\n                            p\\n                        ),\\n                        mload(C_ALPHA_BASE_LOC),\\n                        p\\n                    )\\n\\n                // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n                let y1_plus_y3 := addmod(\\n                    mload(Y1_EVAL_LOC),\\n                    mload(Y3_EVAL_LOC),\\n                    p\\n                )\\n                let y_diff := addmod(mulmod(mload(Y2_EVAL_LOC), mload(QSIGN_LOC), p), sub(p, mload(Y1_EVAL_LOC)), p)\\n                let y_add_identity :=\\n                    addmod(\\n                        mulmod(y1_plus_y3, x_diff, p),\\n                        mulmod(addmod(mload(X3_EVAL_LOC), sub(p, mload(X1_EVAL_LOC)), p), y_diff, p),\\n                        p\\n                    )\\n                y_add_identity :=\\n                    mulmod(\\n                        mulmod(y_add_identity, addmod(1, sub(p, mload(QM_EVAL_LOC)), p), p),\\n                        mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p),\\n                        p\\n                    )\\n\\n                // ELLIPTIC_IDENTITY = (x_identity + y_identity) * Q_ELLIPTIC_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY, mulmod(addmod(x_add_identity, y_add_identity, p), mload(QELLIPTIC_EVAL_LOC), p)\\n                )\\n            }\\n            {\\n                /**\\n                 * x_pow_4 = (y_1_sqr - curve_b) * x_1;\\n                 * y_1_sqr_mul_4 = y_1_sqr + y_1_sqr;\\n                 * y_1_sqr_mul_4 += y_1_sqr_mul_4;\\n                 * x_1_pow_4_mul_9 = x_pow_4;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_1_pow_4_mul_9;\\n                 * x_1_pow_4_mul_9 += x_pow_4;\\n                 * x_1_sqr_mul_3 = x_1_sqr + x_1_sqr + x_1_sqr;\\n                 * x_double_identity = (x_3 + x_1 + x_1) * y_1_sqr_mul_4 - x_1_pow_4_mul_9;\\n                 * y_double_identity = x_1_sqr_mul_3 * (x_1 - x_3) - (y_1 + y_1) * (y_1 + y_3);\\n                 */\\n                // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n                let x1_sqr := mulmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p)\\n                let y1_sqr := mulmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p)\\n                let x_pow_4 := mulmod(addmod(y1_sqr, GRUMPKIN_CURVE_B_PARAMETER_NEGATED, p), mload(X1_EVAL_LOC), p)\\n                let y1_sqr_mul_4 := mulmod(y1_sqr, 4, p)\\n                let x1_pow_4_mul_9 := mulmod(x_pow_4, 9, p)\\n                let x1_sqr_mul_3 := mulmod(x1_sqr, 3, p)\\n                let x_double_identity :=\\n                    addmod(\\n                        mulmod(\\n                            addmod(mload(X3_EVAL_LOC), addmod(mload(X1_EVAL_LOC), mload(X1_EVAL_LOC), p), p),\\n                            y1_sqr_mul_4,\\n                            p\\n                        ),\\n                        sub(p, x1_pow_4_mul_9),\\n                        p\\n                    )\\n                // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n                let y_double_identity :=\\n                    addmod(\\n                        mulmod(x1_sqr_mul_3, addmod(mload(X1_EVAL_LOC), sub(p, mload(X3_EVAL_LOC)), p), p),\\n                        sub(\\n                            p,\\n                            mulmod(\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y1_EVAL_LOC), p),\\n                                addmod(mload(Y1_EVAL_LOC), mload(Y3_EVAL_LOC), p),\\n                                p\\n                            )\\n                        ),\\n                        p\\n                    )\\n                x_double_identity := mulmod(x_double_identity, mload(C_ALPHA_BASE_LOC), p)\\n                y_double_identity :=\\n                    mulmod(y_double_identity, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_LOC), p), p)\\n                x_double_identity := mulmod(x_double_identity, mload(QM_EVAL_LOC), p)\\n                y_double_identity := mulmod(y_double_identity, mload(QM_EVAL_LOC), p)\\n                // ELLIPTIC_IDENTITY += (x_double_identity + y_double_identity) * Q_DOUBLE_EVAL\\n                mstore(\\n                    ELLIPTIC_IDENTITY,\\n                    addmod(\\n                        mload(ELLIPTIC_IDENTITY),\\n                        mulmod(addmod(x_double_identity, y_double_identity, p), mload(QELLIPTIC_EVAL_LOC), p),\\n                        p\\n                    )\\n                )\\n\\n                // update alpha\\n                mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_QUAD_LOC), p))\\n            }\\n\\n            /**\\n             * COMPUTE AUXILIARY WIDGET EVALUATION\\n             */\\n            {\\n                {\\n                    /**\\n                     * Non native field arithmetic gate 2\\n                     *             _                                                                               _\\n                     *            /   _                   _                               _       14                \\\\\\n                     * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n                     *            \\\\_                                                                               _/\\n                     *\\n                     * limb_subproduct = w_1 . w_2_omega + w_1_omega . w_2\\n                     * non_native_field_gate_2 = w_1 * w_4 + w_4 * w_3 - w_3_omega\\n                     * non_native_field_gate_2 = non_native_field_gate_2 * limb_size\\n                     * non_native_field_gate_2 -= w_4_omega\\n                     * non_native_field_gate_2 += limb_subproduct\\n                     * non_native_field_gate_2 *= q_4\\n                     * limb_subproduct *= limb_size\\n                     * limb_subproduct += w_1_omega * w_2_omega\\n                     * non_native_field_gate_1 = (limb_subproduct + w_3 + w_4) * q_3\\n                     * non_native_field_gate_3 = (limb_subproduct + w_4 - (w_3_omega + w_4_omega)) * q_m\\n                     * non_native_field_identity = (non_native_field_gate_1 + non_native_field_gate_2 + non_native_field_gate_3) * q_2\\n                     */\\n\\n                    let limb_subproduct :=\\n                        addmod(\\n                            mulmod(mload(W1_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p),\\n                            mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_EVAL_LOC), p),\\n                            p\\n                        )\\n\\n                    let non_native_field_gate_2 :=\\n                        addmod(\\n                            addmod(\\n                                mulmod(mload(W1_EVAL_LOC), mload(W4_EVAL_LOC), p),\\n                                mulmod(mload(W2_EVAL_LOC), mload(W3_EVAL_LOC), p),\\n                                p\\n                            ),\\n                            sub(p, mload(W3_OMEGA_EVAL_LOC)),\\n                            p\\n                        )\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, LIMB_SIZE, p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    non_native_field_gate_2 := addmod(non_native_field_gate_2, limb_subproduct, p)\\n                    non_native_field_gate_2 := mulmod(non_native_field_gate_2, mload(Q4_EVAL_LOC), p)\\n                    limb_subproduct := mulmod(limb_subproduct, LIMB_SIZE, p)\\n                    limb_subproduct :=\\n                        addmod(limb_subproduct, mulmod(mload(W1_OMEGA_EVAL_LOC), mload(W2_OMEGA_EVAL_LOC), p), p)\\n                    let non_native_field_gate_1 :=\\n                        mulmod(\\n                            addmod(limb_subproduct, sub(p, addmod(mload(W3_EVAL_LOC), mload(W4_EVAL_LOC), p)), p),\\n                            mload(Q3_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_gate_3 :=\\n                        mulmod(\\n                            addmod(\\n                                addmod(limb_subproduct, mload(W4_EVAL_LOC), p),\\n                                sub(p, addmod(mload(W3_OMEGA_EVAL_LOC), mload(W4_OMEGA_EVAL_LOC), p)),\\n                                p\\n                            ),\\n                            mload(QM_EVAL_LOC),\\n                            p\\n                        )\\n                    let non_native_field_identity :=\\n                        mulmod(\\n                            addmod(addmod(non_native_field_gate_1, non_native_field_gate_2, p), non_native_field_gate_3, p),\\n                            mload(Q2_EVAL_LOC),\\n                            p\\n                        )\\n\\n                    mstore(AUX_NON_NATIVE_FIELD_EVALUATION, non_native_field_identity)\\n                }\\n\\n                {\\n                    /**\\n                     * limb_accumulator_1 = w_2_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1_omega;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_3;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_2;\\n                     * limb_accumulator_1 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_1 += w_1;\\n                     * limb_accumulator_1 -= w_4;\\n                     * limb_accumulator_1 *= q_4;\\n                     */\\n                    let limb_accumulator_1 := mulmod(mload(W2_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W2_EVAL_LOC), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, mload(W1_EVAL_LOC), p)\\n                    limb_accumulator_1 := addmod(limb_accumulator_1, sub(p, mload(W4_EVAL_LOC)), p)\\n                    limb_accumulator_1 := mulmod(limb_accumulator_1, mload(Q4_EVAL_LOC), p)\\n\\n                    /**\\n                     * limb_accumulator_2 = w_3_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_2_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_1_omega;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_4;\\n                     * limb_accumulator_2 *= SUBLIMB_SHIFT;\\n                     * limb_accumulator_2 += w_3;\\n                     * limb_accumulator_2 -= w_4_omega;\\n                     * limb_accumulator_2 *= q_m;\\n                     */\\n                    let limb_accumulator_2 := mulmod(mload(W3_OMEGA_EVAL_LOC), SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W2_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W1_OMEGA_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W4_EVAL_LOC), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, SUBLIMB_SHIFT, p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, mload(W3_EVAL_LOC), p)\\n                    limb_accumulator_2 := addmod(limb_accumulator_2, sub(p, mload(W4_OMEGA_EVAL_LOC)), p)\\n                    limb_accumulator_2 := mulmod(limb_accumulator_2, mload(QM_EVAL_LOC), p)\\n\\n                    mstore(\\n                        AUX_LIMB_ACCUMULATOR_EVALUATION,\\n                        mulmod(addmod(limb_accumulator_1, limb_accumulator_2, p), mload(Q3_EVAL_LOC), p)\\n                    )\\n                }\\n\\n                {\\n                    /**\\n                     * memory_record_check = w_3;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_2;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += w_1;\\n                     * memory_record_check *= eta;\\n                     * memory_record_check += q_c;\\n                     *\\n                     * partial_record_check = memory_record_check;\\n                     *\\n                     * memory_record_check -= w_4;\\n                     */\\n\\n                    let memory_record_check := mulmod(mload(W3_EVAL_LOC), mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W2_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(W1_EVAL_LOC), p)\\n                    memory_record_check := mulmod(memory_record_check, mload(C_ETA_LOC), p)\\n                    memory_record_check := addmod(memory_record_check, mload(QC_EVAL_LOC), p)\\n\\n                    let partial_record_check := memory_record_check\\n                    memory_record_check := addmod(memory_record_check, sub(p, mload(W4_EVAL_LOC)), p)\\n\\n                    mstore(AUX_MEMORY_EVALUATION, memory_record_check)\\n\\n                    // index_delta = w_1_omega - w_1\\n                    let index_delta := addmod(mload(W1_OMEGA_EVAL_LOC), sub(p, mload(W1_EVAL_LOC)), p)\\n                    // record_delta = w_4_omega - w_4\\n                    let record_delta := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, mload(W4_EVAL_LOC)), p)\\n                    // index_is_monotonically_increasing = index_delta * (index_delta - 1)\\n                    let index_is_monotonically_increasing := mulmod(index_delta, addmod(index_delta, sub(p, 1), p), p)\\n\\n                    // adjacent_values_match_if_adjacent_indices_match = record_delta * (1 - index_delta)\\n                    let adjacent_values_match_if_adjacent_indices_match :=\\n                        mulmod(record_delta, addmod(1, sub(p, index_delta), p), p)\\n\\n                    // AUX_ROM_CONSISTENCY_EVALUATION = ((adjacent_values_match_if_adjacent_indices_match * alpha) + index_is_monotonically_increasing) * alpha + partial_record_check\\n                    mstore(\\n                        AUX_ROM_CONSISTENCY_EVALUATION,\\n                        addmod(\\n                            mulmod(\\n                                addmod(\\n                                    mulmod(adjacent_values_match_if_adjacent_indices_match, mload(C_ALPHA_LOC), p),\\n                                    index_is_monotonically_increasing,\\n                                    p\\n                                ),\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            ),\\n                            memory_record_check,\\n                            p\\n                        )\\n                    )\\n\\n                    {\\n                        /**\\n                         * next_gate_access_type = w_3_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_2_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type += w_1_omega;\\n                         * next_gate_access_type *= eta;\\n                         * next_gate_access_type = w_4_omega - next_gate_access_type;\\n                         */\\n                        let next_gate_access_type := mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W2_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(next_gate_access_type, mload(W1_OMEGA_EVAL_LOC), p)\\n                        next_gate_access_type := mulmod(next_gate_access_type, mload(C_ETA_LOC), p)\\n                        next_gate_access_type := addmod(mload(W4_OMEGA_EVAL_LOC), sub(p, next_gate_access_type), p)\\n\\n                        // value_delta = w_3_omega - w_3\\n                        let value_delta := addmod(mload(W3_OMEGA_EVAL_LOC), sub(p, mload(W3_EVAL_LOC)), p)\\n                        //  adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (1 - index_delta) * value_delta * (1 - next_gate_access_type);\\n\\n                        let adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation :=\\n                            mulmod(\\n                                addmod(1, sub(p, index_delta), p),\\n                                mulmod(value_delta, addmod(1, sub(p, next_gate_access_type), p), p),\\n                                p\\n                            )\\n\\n                        // AUX_RAM_CONSISTENCY_EVALUATION\\n\\n                        /**\\n                         * access_type = w_4 - partial_record_check\\n                         * access_check = access_type^2 - access_type\\n                         * next_gate_access_type_is_boolean = next_gate_access_type^2 - next_gate_access_type\\n                         * RAM_consistency_check_identity = adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += index_is_monotonically_increasing;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += next_gate_access_type_is_boolean;\\n                         * RAM_consistency_check_identity *= alpha;\\n                         * RAM_consistency_check_identity += access_check;\\n                         */\\n\\n                        let access_type := addmod(mload(W4_EVAL_LOC), sub(p, partial_record_check), p)\\n                        let access_check := mulmod(access_type, addmod(access_type, sub(p, 1), p), p)\\n                        let next_gate_access_type_is_boolean :=\\n                            mulmod(next_gate_access_type, addmod(next_gate_access_type, sub(p, 1), p), p)\\n                        let RAM_cci :=\\n                            mulmod(\\n                                adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation,\\n                                mload(C_ALPHA_LOC),\\n                                p\\n                            )\\n                        RAM_cci := addmod(RAM_cci, index_is_monotonically_increasing, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, next_gate_access_type_is_boolean, p)\\n                        RAM_cci := mulmod(RAM_cci, mload(C_ALPHA_LOC), p)\\n                        RAM_cci := addmod(RAM_cci, access_check, p)\\n\\n                        mstore(AUX_RAM_CONSISTENCY_EVALUATION, RAM_cci)\\n                    }\\n\\n                    {\\n                        // timestamp_delta = w_2_omega - w_2\\n                        let timestamp_delta := addmod(mload(W2_OMEGA_EVAL_LOC), sub(p, mload(W2_EVAL_LOC)), p)\\n\\n                        // RAM_timestamp_check_identity = (1 - index_delta) * timestamp_delta - w_3\\n                        let RAM_timestamp_check_identity :=\\n                            addmod(\\n                                mulmod(timestamp_delta, addmod(1, sub(p, index_delta), p), p), sub(p, mload(W3_EVAL_LOC)), p\\n                            )\\n\\n                        /**\\n                         * memory_identity = ROM_consistency_check_identity * q_2;\\n                         * memory_identity += RAM_timestamp_check_identity * q_4;\\n                         * memory_identity += memory_record_check * q_m;\\n                         * memory_identity *= q_1;\\n                         * memory_identity += (RAM_consistency_check_identity * q_arith);\\n                         *\\n                         * auxiliary_identity = memory_identity + non_native_field_identity + limb_accumulator_identity;\\n                         * auxiliary_identity *= q_aux;\\n                         * auxiliary_identity *= alpha_base;\\n                         */\\n                        let memory_identity := mulmod(mload(AUX_ROM_CONSISTENCY_EVALUATION), mload(Q2_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(RAM_timestamp_check_identity, mload(Q4_EVAL_LOC), p), p)\\n                        memory_identity :=\\n                            addmod(memory_identity, mulmod(mload(AUX_MEMORY_EVALUATION), mload(QM_EVAL_LOC), p), p)\\n                        memory_identity := mulmod(memory_identity, mload(Q1_EVAL_LOC), p)\\n                        memory_identity :=\\n                            addmod(\\n                                memory_identity, mulmod(mload(AUX_RAM_CONSISTENCY_EVALUATION), mload(QARITH_EVAL_LOC), p), p\\n                            )\\n\\n                        let auxiliary_identity := addmod(memory_identity, mload(AUX_NON_NATIVE_FIELD_EVALUATION), p)\\n                        auxiliary_identity := addmod(auxiliary_identity, mload(AUX_LIMB_ACCUMULATOR_EVALUATION), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(QAUX_EVAL_LOC), p)\\n                        auxiliary_identity := mulmod(auxiliary_identity, mload(C_ALPHA_BASE_LOC), p)\\n\\n                        mstore(AUX_IDENTITY, auxiliary_identity)\\n\\n                        // update alpha\\n                        mstore(C_ALPHA_BASE_LOC, mulmod(mload(C_ALPHA_BASE_LOC), mload(C_ALPHA_CUBE_LOC), p))\\n                    }\\n                }\\n            }\\n\\n            {\\n                /**\\n                 * quotient = ARITHMETIC_IDENTITY\\n                 * quotient += PERMUTATION_IDENTITY\\n                 * quotient += PLOOKUP_IDENTITY\\n                 * quotient += SORT_IDENTITY\\n                 * quotient += ELLIPTIC_IDENTITY\\n                 * quotient += AUX_IDENTITY\\n                 * quotient *= ZERO_POLY_INVERSE\\n                 */\\n                mstore(\\n                    QUOTIENT_EVAL_LOC,\\n                    mulmod(\\n                        addmod(\\n                            addmod(\\n                                addmod(\\n                                    addmod(\\n                                        addmod(mload(PERMUTATION_IDENTITY), mload(PLOOKUP_IDENTITY), p),\\n                                        mload(ARITHMETIC_IDENTITY),\\n                                        p\\n                                    ),\\n                                    mload(SORT_IDENTITY),\\n                                    p\\n                                ),\\n                                mload(ELLIPTIC_IDENTITY),\\n                                p\\n                            ),\\n                            mload(AUX_IDENTITY),\\n                            p\\n                        ),\\n                        mload(ZERO_POLY_INVERSE_LOC),\\n                        p\\n                    )\\n                )\\n            }\\n\\n            /**\\n             * GENERATE NU AND SEPARATOR CHALLENGES\\n             */\\n            {\\n                let current_challenge := mload(C_CURRENT_LOC)\\n                // get a calldata pointer that points to the start of the data we want to copy\\n                let calldata_ptr := add(calldataload(0x04), 0x24)\\n\\n                calldata_ptr := add(calldata_ptr, NU_CALLDATA_SKIP_LENGTH)\\n\\n                mstore(NU_CHALLENGE_INPUT_LOC_A, current_challenge)\\n                mstore(NU_CHALLENGE_INPUT_LOC_B, mload(QUOTIENT_EVAL_LOC))\\n                calldatacopy(NU_CHALLENGE_INPUT_LOC_C, calldata_ptr, NU_INPUT_LENGTH)\\n\\n                // hash length = (0x20 + num field elements), we include the previous challenge in the hash\\n                let challenge := keccak256(NU_CHALLENGE_INPUT_LOC_A, add(NU_INPUT_LENGTH, 0x40))\\n\\n                mstore(C_V0_LOC, mod(challenge, p))\\n                // We need THIRTY-ONE independent nu challenges!\\n                mstore(0x00, challenge)\\n                mstore8(0x20, 0x01)\\n                mstore(C_V1_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x02)\\n                mstore(C_V2_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x03)\\n                mstore(C_V3_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x04)\\n                mstore(C_V4_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x05)\\n                mstore(C_V5_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x06)\\n                mstore(C_V6_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x07)\\n                mstore(C_V7_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x08)\\n                mstore(C_V8_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x09)\\n                mstore(C_V9_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0a)\\n                mstore(C_V10_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0b)\\n                mstore(C_V11_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0c)\\n                mstore(C_V12_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0d)\\n                mstore(C_V13_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0e)\\n                mstore(C_V14_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x0f)\\n                mstore(C_V15_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x10)\\n                mstore(C_V16_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x11)\\n                mstore(C_V17_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x12)\\n                mstore(C_V18_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x13)\\n                mstore(C_V19_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x14)\\n                mstore(C_V20_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x15)\\n                mstore(C_V21_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x16)\\n                mstore(C_V22_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x17)\\n                mstore(C_V23_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x18)\\n                mstore(C_V24_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x19)\\n                mstore(C_V25_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1a)\\n                mstore(C_V26_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1b)\\n                mstore(C_V27_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1c)\\n                mstore(C_V28_LOC, mod(keccak256(0x00, 0x21), p))\\n                mstore8(0x20, 0x1d)\\n                mstore(C_V29_LOC, mod(keccak256(0x00, 0x21), p))\\n\\n                // @follow-up - Why are both v29 and v30 using appending 0x1d to the prior challenge and hashing, should it not change?\\n                mstore8(0x20, 0x1d)\\n                challenge := keccak256(0x00, 0x21)\\n                mstore(C_V30_LOC, mod(challenge, p))\\n\\n                // separator\\n                mstore(0x00, challenge)\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, mload(PI_Z_OMEGA_X_LOC))\\n\\n                mstore(C_U_LOC, mod(keccak256(0x00, 0xa0), p))\\n            }\\n\\n            let success := 0\\n            // VALIDATE T1\\n            {\\n                let x := mload(T1_X_LOC)\\n                let y := mload(T1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                mstore(ACCUMULATOR_X_LOC, x)\\n                mstore(add(ACCUMULATOR_X_LOC, 0x20), y)\\n            }\\n            // VALIDATE T2\\n            {\\n                let x := mload(T2_X_LOC) // 0x1400\\n                let y := mload(T2_Y_LOC) // 0x1420\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(ZETA_POW_N_LOC))\\n            // accumulator_2 = [T2].zeta^n\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = [T1] + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T3\\n            {\\n                let x := mload(T3_X_LOC)\\n                let y := mload(T3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T3].zeta^{2n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE T4\\n            {\\n                let x := mload(T4_X_LOC)\\n                let y := mload(T4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(mulmod(mload(ZETA_POW_N_LOC), mload(ZETA_POW_N_LOC), p), mload(ZETA_POW_N_LOC), p))\\n            // accumulator_2 = [T4].zeta^{3n}\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W1\\n            {\\n                let x := mload(W1_X_LOC)\\n                let y := mload(W1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V0_LOC), p))\\n            // accumulator_2 = v0.(u + 1).[W1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W2\\n            {\\n                let x := mload(W2_X_LOC)\\n                let y := mload(W2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V1_LOC), p))\\n            // accumulator_2 = v1.(u + 1).[W2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W3\\n            {\\n                let x := mload(W3_X_LOC)\\n                let y := mload(W3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V2_LOC), p))\\n            // accumulator_2 = v2.(u + 1).[W3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE W4\\n            {\\n                let x := mload(W4_X_LOC)\\n                let y := mload(W4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V3_LOC), p))\\n            // accumulator_2 = v3.(u + 1).[W4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE S\\n            {\\n                let x := mload(S_X_LOC)\\n                let y := mload(S_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V4_LOC), p))\\n            // accumulator_2 = v4.(u + 1).[S]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z\\n            {\\n                let x := mload(Z_X_LOC)\\n                let y := mload(Z_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V5_LOC), p))\\n            // accumulator_2 = v5.(u + 1).[Z]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Z_LOOKUP\\n            {\\n                let x := mload(Z_LOOKUP_X_LOC)\\n                let y := mload(Z_LOOKUP_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V6_LOC), p))\\n            // accumulator_2 = v6.(u + 1).[Z_LOOKUP]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q1\\n            {\\n                let x := mload(Q1_X_LOC)\\n                let y := mload(Q1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V7_LOC))\\n            // accumulator_2 = v7.[Q1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q2\\n            {\\n                let x := mload(Q2_X_LOC)\\n                let y := mload(Q2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V8_LOC))\\n            // accumulator_2 = v8.[Q2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q3\\n            {\\n                let x := mload(Q3_X_LOC)\\n                let y := mload(Q3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V9_LOC))\\n            // accumulator_2 = v9.[Q3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE Q4\\n            {\\n                let x := mload(Q4_X_LOC)\\n                let y := mload(Q4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V10_LOC))\\n            // accumulator_2 = v10.[Q4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QM\\n            {\\n                let x := mload(QM_X_LOC)\\n                let y := mload(QM_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V11_LOC))\\n            // accumulator_2 = v11.[Q;]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QC\\n            {\\n                let x := mload(QC_X_LOC)\\n                let y := mload(QC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V12_LOC))\\n            // accumulator_2 = v12.[QC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QARITH\\n            {\\n                let x := mload(QARITH_X_LOC)\\n                let y := mload(QARITH_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V13_LOC))\\n            // accumulator_2 = v13.[QARITH]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QSORT\\n            {\\n                let x := mload(QSORT_X_LOC)\\n                let y := mload(QSORT_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V14_LOC))\\n            // accumulator_2 = v14.[QSORT]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QELLIPTIC\\n            {\\n                let x := mload(QELLIPTIC_X_LOC)\\n                let y := mload(QELLIPTIC_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V15_LOC))\\n            // accumulator_2 = v15.[QELLIPTIC]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE QAUX\\n            {\\n                let x := mload(QAUX_X_LOC)\\n                let y := mload(QAUX_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V16_LOC))\\n            // accumulator_2 = v15.[Q_AUX]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA1\\n            {\\n                let x := mload(SIGMA1_X_LOC)\\n                let y := mload(SIGMA1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V17_LOC))\\n            // accumulator_2 = v17.[sigma1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA2\\n            {\\n                let x := mload(SIGMA2_X_LOC)\\n                let y := mload(SIGMA2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V18_LOC))\\n            // accumulator_2 = v18.[sigma2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA3\\n            {\\n                let x := mload(SIGMA3_X_LOC)\\n                let y := mload(SIGMA3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V19_LOC))\\n            // accumulator_2 = v19.[sigma3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE SIGMA4\\n            {\\n                let x := mload(SIGMA4_X_LOC)\\n                let y := mload(SIGMA4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V20_LOC))\\n            // accumulator_2 = v20.[sigma4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE1\\n            {\\n                let x := mload(TABLE1_X_LOC)\\n                let y := mload(TABLE1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V21_LOC), p))\\n            // accumulator_2 = u.[table1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE2\\n            {\\n                let x := mload(TABLE2_X_LOC)\\n                let y := mload(TABLE2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V22_LOC), p))\\n            // accumulator_2 = u.[table2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE3\\n            {\\n                let x := mload(TABLE3_X_LOC)\\n                let y := mload(TABLE3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V23_LOC), p))\\n            // accumulator_2 = u.[table3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE4\\n            {\\n                let x := mload(TABLE4_X_LOC)\\n                let y := mload(TABLE4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mulmod(addmod(mload(C_U_LOC), 0x1, p), mload(C_V24_LOC), p))\\n            // accumulator_2 = u.[table4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE TABLE_TYPE\\n            {\\n                let x := mload(TABLE_TYPE_X_LOC)\\n                let y := mload(TABLE_TYPE_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V25_LOC))\\n            // accumulator_2 = v25.[TableType]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID1\\n            {\\n                let x := mload(ID1_X_LOC)\\n                let y := mload(ID1_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V26_LOC))\\n            // accumulator_2 = v26.[ID1]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID2\\n            {\\n                let x := mload(ID2_X_LOC)\\n                let y := mload(ID2_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V27_LOC))\\n            // accumulator_2 = v27.[ID2]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID3\\n            {\\n                let x := mload(ID3_X_LOC)\\n                let y := mload(ID3_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V28_LOC))\\n            // accumulator_2 = v28.[ID3]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            // VALIDATE ID4\\n            {\\n                let x := mload(ID4_X_LOC)\\n                let y := mload(ID4_Y_LOC)\\n                let xx := mulmod(x, x, q)\\n                // validate on curve\\n                success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                mstore(0x00, x)\\n                mstore(0x20, y)\\n            }\\n            mstore(0x40, mload(C_V29_LOC))\\n            // accumulator_2 = v29.[ID4]\\n            success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n            // accumulator = accumulator + accumulator_2\\n            success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n            /**\\n             * COMPUTE BATCH EVALUATION SCALAR MULTIPLIER\\n             */\\n            {\\n                /**\\n                 * batch_evaluation = v0 * (w_1_omega * u + w_1_eval)\\n                 * batch_evaluation += v1 * (w_2_omega * u + w_2_eval)\\n                 * batch_evaluation += v2 * (w_3_omega * u + w_3_eval)\\n                 * batch_evaluation += v3 * (w_4_omega * u + w_4_eval)\\n                 * batch_evaluation += v4 * (s_omega_eval * u + s_eval)\\n                 * batch_evaluation += v5 * (z_omega_eval * u + z_eval)\\n                 * batch_evaluation += v6 * (z_lookup_omega_eval * u + z_lookup_eval)\\n                 */\\n                let batch_evaluation :=\\n                    mulmod(\\n                        mload(C_V0_LOC),\\n                        addmod(mulmod(mload(W1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W1_EVAL_LOC), p),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V1_LOC),\\n                            addmod(mulmod(mload(W2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V2_LOC),\\n                            addmod(mulmod(mload(W3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V3_LOC),\\n                            addmod(mulmod(mload(W4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(W4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V4_LOC),\\n                            addmod(mulmod(mload(S_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(S_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V5_LOC),\\n                            addmod(mulmod(mload(Z_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V6_LOC),\\n                            addmod(mulmod(mload(Z_LOOKUP_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(Z_LOOKUP_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n\\n                /**\\n                 * batch_evaluation += v7 * Q1_EVAL\\n                 * batch_evaluation += v8 * Q2_EVAL\\n                 * batch_evaluation += v9 * Q3_EVAL\\n                 * batch_evaluation += v10 * Q4_EVAL\\n                 * batch_evaluation += v11 * QM_EVAL\\n                 * batch_evaluation += v12 * QC_EVAL\\n                 * batch_evaluation += v13 * QARITH_EVAL\\n                 * batch_evaluation += v14 * QSORT_EVAL_LOC\\n                 * batch_evaluation += v15 * QELLIPTIC_EVAL_LOC\\n                 * batch_evaluation += v16 * QAUX_EVAL_LOC\\n                 * batch_evaluation += v17 * SIGMA1_EVAL_LOC\\n                 * batch_evaluation += v18 * SIGMA2_EVAL_LOC\\n                 * batch_evaluation += v19 * SIGMA3_EVAL_LOC\\n                 * batch_evaluation += v20 * SIGMA4_EVAL_LOC\\n                 */\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V7_LOC), mload(Q1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V8_LOC), mload(Q2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V9_LOC), mload(Q3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V10_LOC), mload(Q4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V11_LOC), mload(QM_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V12_LOC), mload(QC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V13_LOC), mload(QARITH_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V14_LOC), mload(QSORT_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V15_LOC), mload(QELLIPTIC_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V16_LOC), mload(QAUX_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V17_LOC), mload(SIGMA1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V18_LOC), mload(SIGMA2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V19_LOC), mload(SIGMA3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V20_LOC), mload(SIGMA4_EVAL_LOC), p), p)\\n\\n                /**\\n                 * batch_evaluation += v21 * (table1(zw) * u + table1(z))\\n                 * batch_evaluation += v22 * (table2(zw) * u + table2(z))\\n                 * batch_evaluation += v23 * (table3(zw) * u + table3(z))\\n                 * batch_evaluation += v24 * (table4(zw) * u + table4(z))\\n                 * batch_evaluation += v25 * table_type_eval\\n                 * batch_evaluation += v26 * id1_eval\\n                 * batch_evaluation += v27 * id2_eval\\n                 * batch_evaluation += v28 * id3_eval\\n                 * batch_evaluation += v29 * id4_eval\\n                 * batch_evaluation += quotient_eval\\n                 */\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V21_LOC),\\n                            addmod(mulmod(mload(TABLE1_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE1_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V22_LOC),\\n                            addmod(mulmod(mload(TABLE2_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE2_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V23_LOC),\\n                            addmod(mulmod(mload(TABLE3_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE3_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation :=\\n                    addmod(\\n                        batch_evaluation,\\n                        mulmod(\\n                            mload(C_V24_LOC),\\n                            addmod(mulmod(mload(TABLE4_OMEGA_EVAL_LOC), mload(C_U_LOC), p), mload(TABLE4_EVAL_LOC), p),\\n                            p\\n                        ),\\n                        p\\n                    )\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V25_LOC), mload(TABLE_TYPE_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V26_LOC), mload(ID1_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V27_LOC), mload(ID2_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V28_LOC), mload(ID3_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mulmod(mload(C_V29_LOC), mload(ID4_EVAL_LOC), p), p)\\n                batch_evaluation := addmod(batch_evaluation, mload(QUOTIENT_EVAL_LOC), p)\\n\\n                mstore(0x00, 0x01) // [1].x\\n                mstore(0x20, 0x02) // [1].y\\n                mstore(0x40, sub(p, batch_evaluation))\\n                // accumulator_2 = -[1].(batch_evaluation)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                mstore(OPENING_COMMITMENT_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING PREAMBLE\\n             */\\n            {\\n                let u := mload(C_U_LOC)\\n                let zeta := mload(C_ZETA_LOC)\\n                // VALIDATE PI_Z\\n                {\\n                    let x := mload(PI_Z_X_LOC)\\n                    let y := mload(PI_Z_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(0x40, zeta)\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, ACCUMULATOR_X_LOC, 0x40))\\n\\n                // VALIDATE PI_Z_OMEGA\\n                {\\n                    let x := mload(PI_Z_OMEGA_X_LOC)\\n                    let y := mload(PI_Z_OMEGA_Y_LOC)\\n                    let xx := mulmod(x, x, q)\\n                    // validate on curve\\n                    success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                    mstore(0x00, x)\\n                    mstore(0x20, y)\\n                }\\n                mstore(0x40, mulmod(mulmod(u, zeta, p), mload(OMEGA_LOC), p))\\n                // accumulator_2 = u.zeta.omega.[PI_Z_OMEGA]\\n                success := and(success, staticcall(gas(), 7, 0x00, 0x60, ACCUMULATOR2_X_LOC, 0x40))\\n                // PAIRING_RHS = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, ACCUMULATOR_X_LOC, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                mstore(0x00, mload(PI_Z_X_LOC))\\n                mstore(0x20, mload(PI_Z_Y_LOC))\\n                mstore(0x40, mload(PI_Z_OMEGA_X_LOC))\\n                mstore(0x60, mload(PI_Z_OMEGA_Y_LOC))\\n                mstore(0x80, u)\\n                success := and(success, staticcall(gas(), 7, 0x40, 0x60, 0x40, 0x40))\\n                // PAIRING_LHS = [PI_Z] + [PI_Z_OMEGA] * u\\n                success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                // negate lhs y-coordinate\\n                mstore(PAIRING_LHS_Y_LOC, sub(q, mload(PAIRING_LHS_Y_LOC)))\\n\\n                if mload(CONTAINS_RECURSIVE_PROOF_LOC) {\\n                    // VALIDATE RECURSIVE P1\\n                    {\\n                        let x := mload(RECURSIVE_P1_X_LOC)\\n                        let y := mload(RECURSIVE_P1_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n\\n                    // compute u.u.[recursive_p1] and write into 0x60\\n                    mstore(0x40, mulmod(u, u, p))\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x60, 0x40))\\n                    // VALIDATE RECURSIVE P2\\n                    {\\n                        let x := mload(RECURSIVE_P2_X_LOC)\\n                        let y := mload(RECURSIVE_P2_Y_LOC)\\n                        let xx := mulmod(x, x, q)\\n                        // validate on curve\\n                        success := and(success, eq(mulmod(y, y, q), addmod(mulmod(x, xx, q), 3, q)))\\n                        mstore(0x00, x)\\n                        mstore(0x20, y)\\n                    }\\n                    // compute u.u.[recursive_p2] and write into 0x00\\n                    // 0x40 still contains u*u\\n                    success := and(success, staticcall(gas(), 7, 0x00, 0x60, 0x00, 0x40))\\n\\n                    // compute u.u.[recursiveP1] + rhs and write into rhs\\n                    mstore(0xa0, mload(PAIRING_RHS_X_LOC))\\n                    mstore(0xc0, mload(PAIRING_RHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x60, 0x80, PAIRING_RHS_X_LOC, 0x40))\\n\\n                    // compute u.u.[recursiveP2] + lhs and write into lhs\\n                    mstore(0x40, mload(PAIRING_LHS_X_LOC))\\n                    mstore(0x60, mload(PAIRING_LHS_Y_LOC))\\n                    success := and(success, staticcall(gas(), 6, 0x00, 0x80, PAIRING_LHS_X_LOC, 0x40))\\n                }\\n\\n                if iszero(success) {\\n                    mstore(0x0, EC_SCALAR_MUL_FAILURE_SELECTOR)\\n                    revert(0x00, 0x04)\\n                }\\n                mstore(PAIRING_PREAMBLE_SUCCESS_FLAG, success)\\n            }\\n\\n            /**\\n             * PERFORM PAIRING\\n             */\\n            {\\n                // rhs paired with [1]_2\\n                // lhs paired with [x]_2\\n\\n                mstore(0x00, mload(PAIRING_RHS_X_LOC))\\n                mstore(0x20, mload(PAIRING_RHS_Y_LOC))\\n                mstore(0x40, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2) // this is [1]_2\\n                mstore(0x60, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\\n                mstore(0x80, 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\\n                mstore(0xa0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\\n\\n                mstore(0xc0, mload(PAIRING_LHS_X_LOC))\\n                mstore(0xe0, mload(PAIRING_LHS_Y_LOC))\\n                mstore(0x100, mload(G2X_X0_LOC))\\n                mstore(0x120, mload(G2X_X1_LOC))\\n                mstore(0x140, mload(G2X_Y0_LOC))\\n                mstore(0x160, mload(G2X_Y1_LOC))\\n\\n                success := staticcall(gas(), 8, 0x00, 0x180, 0x00, 0x20)\\n                mstore(PAIRING_SUCCESS_FLAG, success)\\n                mstore(RESULT_FLAG, mload(0x00))\\n            }\\n            if iszero(\\n                and(\\n                    and(and(mload(PAIRING_SUCCESS_FLAG), mload(RESULT_FLAG)), mload(PAIRING_PREAMBLE_SUCCESS_FLAG)),\\n                    mload(OPENING_COMMITMENT_SUCCESS_FLAG)\\n                )\\n            ) {\\n                mstore(0x0, PROOF_FAILURE_SELECTOR)\\n                revert(0x00, 0x04)\\n            }\\n            {\\n                mstore(0x00, 0x01)\\n                return(0x00, 0x20) // Proof succeeded!\\n            }\\n        }\\n    }\\n}\\n\\ncontract RecoveryUltraVerifier is RecoveryBaseUltraVerifier {\\n    function getVerificationKeyHash() public pure override(RecoveryBaseUltraVerifier) returns (bytes32) {\\n        return RecoveryUltraVerificationKey.verificationKeyHash();\\n    }\\n\\n    function loadVerificationKey(uint256 vk, uint256 _omegaInverseLoc) internal pure virtual override(RecoveryBaseUltraVerifier) {\\n        RecoveryUltraVerificationKey.loadVerificationKey(vk, _omegaInverseLoc);\\n    }\\n}\\n\",\"keccak256\":\"0x89c96d7d85a54ec8c6e764bb1d1969b0e5261d035bd4feafa6ea36253d9c0c78\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60c06040523480156200001157600080fd5b5060405162002fb238038062002fb28339810160408190526200003491620000d4565b6001600160a01b0383166080526040513090839083906200005590620000a9565b6001600160a01b03938416815291831660208301529091166040820152606001604051809103906000f08015801562000092573d6000803e3d6000fd5b506001600160a01b031660a052506200011e915050565b6115e680620019cc83390190565b80516001600160a01b0381168114620000cf57600080fd5b919050565b600080600060608486031215620000ea57600080fd5b620000f584620000b7565b92506200010560208501620000b7565b91506200011560408501620000b7565b90509250925092565b60805160a05161187a62000152600039600081816101100152818161066401526107d001526000610425015261187a6000f3fe60806040523480156200001157600080fd5b5060043610620000ab5760003560e01c80639ceac563116200006e5780639ceac5631462000162578063becd18aa14620001a0578063d9e374ef14620001b7578063dc55776f146200021a578063f936d15b146200023157600080fd5b80631a095c6014620000b057806347f7d84d14620000dc578063572b6c0514620000f35780636ff56aa4146200010a57806395083b73146200014b575b600080fd5b620000c7620000c136600462000ac5565b62000248565b60405190151581526020015b60405180910390f35b620000c7620000ed36600462000bcb565b62000337565b620000c76200010436600462000cc6565b62000423565b620001327f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001620000d3565b620000c76200015c36600462000ce4565b62000455565b620001796200017336600462000d5b565b62000532565b6040805182516001600160a01b0316815260209283015115159281019290925201620000d3565b620000c7620001b136600462000ce4565b62000597565b620001fa620001c836600462000d5b565b80516020818301810180516000825292820191909301209152546001600160a01b03811690600160a01b900460ff1682565b604080516001600160a01b039093168352901515602083015201620000d3565b620001326200022b36600462000d94565b62000623565b620001326200024236600462000dc1565b62000706565b6000620002553362000423565b6200027d5760405162461bcd60e51b8152600401620002749062000e19565b60405180910390fd5b87620002898162000870565b6000808a6040516200029c919062000e88565b9081526040519081900360200181205463775a5d7f60e11b82526001600160a01b03169150819063eeb4bafe90620002e3908c908c908c908c908c908c9060040162000ecf565b6020604051808303816000875af115801562000303573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000329919062000f1d565b9a9950505050505050505050565b6000620003443362000423565b620003635760405162461bcd60e51b8152600401620002749062000e19565b896200036f8162000870565b6000808c60405162000382919062000e88565b90815260405190819003602001812054637659accb60e01b82526001600160a01b031691508190637659accb90620003cd908e908e908e908e908e908e908e908e9060040162000fda565b6020604051808303816000875af1158015620003ed573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000413919062000f1d565b9c9b505050505050505050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b6000620004623362000423565b620004815760405162461bcd60e51b8152600401620002749062000e19565b846200048d8162000870565b60008087604051620004a0919062000e88565b9081526040519081900360200181205463277c3bc360e11b82526001600160a01b031691508190634ef8778690620004e19089908990899060040162001080565b6020604051808303816000875af115801562000501573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000527919062000f1d565b979650505050505050565b60408051808201909152600080825260208201526000808360405162000559919062000e88565b90815260408051918290036020908101832083830190925290546001600160a01b038116835260ff600160a01b909104161515908201529392505050565b6000620005a43362000423565b620005c35760405162461bcd60e51b8152600401620002749062000e19565b84620005cf8162000870565b60008087604051620005e2919062000e88565b90815260405190819003602001812054636a38d70360e01b82526001600160a01b031691508190636a38d70390620004e19089908990899060040162001080565b6000620006fe8260001b604051806020016200063f90620009a3565b601f1982820381018352601f90910116604081905260248101889052604481018790527f00000000000000000000000000000000000000000000000000000000000000009060640160408051601f19818403018152918152602080830180516001600160e01b03166337b709c360e21b1790529051620006c293929101620010a6565b60408051601f1981840301815290829052620006e29291602001620010ea565b60405160208183030381529060405280519060200120620008ee565b949350505050565b6000808560405162000719919062000e88565b9081526040519081900360200190205460ff600160a01b90910416156200078f5760405162461bcd60e51b815260206004820152602360248201527f43656c65737469616c3a2043656c65737469616c20616c72656164792065786960448201526273747360e81b606482015260840162000274565b60006200079e85858562000623565b90506001600160a01b0381163b8015620007bb57509050620006fe565b604051602481018790526044810186905284907f00000000000000000000000000000000000000000000000000000000000000009060640160408051601f198184030181529181526020820180516001600160e01b03166337b709c360e21b179052516200082990620009a3565b62000836929190620010a6565b8190604051809103906000f590508015801562000857573d6000803e3d6000fd5b50925062000866878462000904565b5050949350505050565b60008160405162000882919062000e88565b9081526040519081900360200190205460ff600160a01b90910416620008eb5760405162461bcd60e51b815260206004820152601c60248201527f43656c65737469616c3a20496e76616c69642043656c65737469616c00000000604482015260640162000274565b50565b6000620008fd83833062000979565b9392505050565b6040805180820182526001600160a01b03831681526001602082015290516000906200093290859062000e88565b908152604051602091819003820190208251815493909201516001600160a01b039092166001600160a81b031990931692909217600160a01b911515919091021790555050565b6000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b610727806200111e83390190565b634e487b7160e01b600052604160045260246000fd5b600082601f830112620009d957600080fd5b813567ffffffffffffffff80821115620009f757620009f7620009b1565b604051601f8301601f19908116603f0116810190828211818310171562000a225762000a22620009b1565b8160405283815286602085880101111562000a3c57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008083601f84011262000a6f57600080fd5b50813567ffffffffffffffff81111562000a8857600080fd5b60208301915083602082850101111562000aa157600080fd5b9250929050565b80356001600160a01b038116811462000ac057600080fd5b919050565b600080600080600080600060a0888a03121562000ae157600080fd5b873567ffffffffffffffff8082111562000afa57600080fd5b62000b088b838c01620009c7565b985060208a013591508082111562000b1f57600080fd5b62000b2d8b838c0162000a5c565b909850965086915062000b4360408b0162000aa8565b955060608a0135945060808a013591508082111562000b6157600080fd5b5062000b708a828b0162000a5c565b989b979a50959850939692959293505050565b60008083601f84011262000b9657600080fd5b50813567ffffffffffffffff81111562000baf57600080fd5b6020830191508360208260051b850101111562000aa157600080fd5b600080600080600080600080600060a08a8c03121562000bea57600080fd5b893567ffffffffffffffff8082111562000c0357600080fd5b62000c118d838e01620009c7565b9a5060208c013591508082111562000c2857600080fd5b62000c368d838e0162000a5c565b909a50985060408c013591508082111562000c5057600080fd5b62000c5e8d838e0162000b83565b909850965060608c013591508082111562000c7857600080fd5b62000c868d838e0162000b83565b909650945060808c013591508082111562000ca057600080fd5b5062000caf8c828d0162000b83565b915080935050809150509295985092959850929598565b60006020828403121562000cd957600080fd5b620008fd8262000aa8565b6000806000806060858703121562000cfb57600080fd5b843567ffffffffffffffff8082111562000d1457600080fd5b62000d2288838901620009c7565b9550602087013591508082111562000d3957600080fd5b5062000d488782880162000a5c565b9598909750949560400135949350505050565b60006020828403121562000d6e57600080fd5b813567ffffffffffffffff81111562000d8657600080fd5b620006fe84828501620009c7565b60008060006060848603121562000daa57600080fd5b505081359360208301359350604090920135919050565b6000806000806080858703121562000dd857600080fd5b843567ffffffffffffffff81111562000df057600080fd5b62000dfe87828801620009c7565b97602087013597506040870135966060013595509350505050565b60208082526029908201527f56555a493a2063616c6c6572206973206e6f74207468652074727573746564206040820152683337b93bb0b93232b960b91b606082015260800190565b60005b8381101562000e7f57818101518382015260200162000e65565b50506000910152565b6000825162000e9c81846020870162000e62565b9190910192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60808152600062000ee560808301888a62000ea6565b6001600160a01b038716602084015260408301869052828103606084015262000f1081858762000ea6565b9998505050505050505050565b60006020828403121562000f3057600080fd5b81518015158114620008fd57600080fd5b81835260006020808501808196508560051b810191508460005b8781101562000fcd5782840389528135601e1988360301811262000f7e57600080fd5b8701858101903567ffffffffffffffff81111562000f9b57600080fd5b80360382131562000fab57600080fd5b62000fb886828462000ea6565b9a87019a955050509084019060010162000f5b565b5091979650505050505050565b60808152600062000ff0608083018a8c62000ea6565b8281036020848101919091528882528991810160005b8a81101562001036576001600160a01b03620010228562000aa8565b168252928201929082019060010162001006565b5084810360408601528781526001600160fb1b038811156200105757600080fd5b8760051b9250828983830137909101838103820160608501529062000413818301868862000f41565b6040815260006200109660408301858762000ea6565b9050826020830152949350505050565b60018060a01b03831681526040602082015260008251806040840152620010d581606085016020870162000e62565b601f01601f1916919091016060019392505050565b60008351620010fe81846020880162000e62565b8351908301906200111481836020880162000e62565b0194935050505056fe608060405260405161072738038061072783398101604081905261002291610319565b61002e82826000610035565b5050610436565b61003e8361006b565b60008251118061004b5750805b156100665761006483836100ab60201b6100291760201c565b505b505050565b610074816100d7565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606100d08383604051806060016040528060278152602001610700602791396101a9565b9392505050565b6100ea8161022260201b6100551760201c565b6101515760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084015b60405180910390fd5b806101887f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b61023160201b6100641760201c565b80546001600160a01b0319166001600160a01b039290921691909117905550565b6060600080856001600160a01b0316856040516101c691906103e7565b600060405180830381855af49150503d8060008114610201576040519150601f19603f3d011682016040523d82523d6000602084013e610206565b606091505b50909250905061021886838387610234565b9695505050505050565b6001600160a01b03163b151590565b90565b606083156102a357825160000361029c576001600160a01b0385163b61029c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610148565b50816102ad565b6102ad83836102b5565b949350505050565b8151156102c55781518083602001fd5b8060405162461bcd60e51b81526004016101489190610403565b634e487b7160e01b600052604160045260246000fd5b60005b838110156103105781810151838201526020016102f8565b50506000910152565b6000806040838503121561032c57600080fd5b82516001600160a01b038116811461034357600080fd5b60208401519092506001600160401b038082111561036057600080fd5b818501915085601f83011261037457600080fd5b815181811115610386576103866102df565b604051601f8201601f19908116603f011681019083821181831017156103ae576103ae6102df565b816040528281528860208487010111156103c757600080fd5b6103d88360208301602088016102f5565b80955050505050509250929050565b600082516103f98184602087016102f5565b9190910192915050565b60208152600082518060208401526104228160408501602087016102f5565b601f01601f19169190910160400192915050565b6102bb806104456000396000f3fe60806040523661001357610011610017565b005b6100115b610027610022610067565b61009f565b565b606061004e838360405180606001604052806027815260200161025f602791396100c3565b9392505050565b6001600160a01b03163b151590565b90565b600061009a7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b905090565b3660008037600080366000845af43d6000803e8080156100be573d6000f35b3d6000fd5b6060600080856001600160a01b0316856040516100e0919061020f565b600060405180830381855af49150503d806000811461011b576040519150601f19603f3d011682016040523d82523d6000602084013e610120565b606091505b50915091506101318683838761013b565b9695505050505050565b606083156101af5782516000036101a8576001600160a01b0385163b6101a85760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064015b60405180910390fd5b50816101b9565b6101b983836101c1565b949350505050565b8151156101d15781518083602001fd5b8060405162461bcd60e51b815260040161019f919061022b565b60005b838110156102065781810151838201526020016101ee565b50506000910152565b600082516102218184602087016101eb565b9190910192915050565b602081526000825180602084015261024a8160408501602087016101eb565b601f01601f1916919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220df5e088a16650cdc3010db20ecd1e2b26729605480c947e2f8d77aac24e8ff8464736f6c63430008110033416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212203f2470c04963f6dc3f34f4b7ba69c482496dd15cf524094cb9d7834fa935ff9464736f6c6343000811003360e06040523480156200001157600080fd5b50604051620015e6380380620015e683398101604081905262000034916200006f565b6001600160a01b0392831660805290821660a0521660c052620000b9565b80516001600160a01b03811681146200006a57600080fd5b919050565b6000806000606084860312156200008557600080fd5b620000908462000052565b9250620000a06020850162000052565b9150620000b06040850162000052565b90509250925092565b60805160a05160c0516114ef620000f7600039600081816102ed01526104ae01526000818161024d015261066e015260006102b901526114ef6000f3fe6080604052600436106101005760003560e01c80638315ed851161008f578063bc197c8111610061578063bc197c811461030f578063d087d2881461033e578063dedc270c14610353578063eeb4bafe14610373578063f23a6e611461038657005b80638315ed851461023b5780638ee06ddd1461028757806394dacaaa146102a7578063a8b56de2146102db57005b80634ef87786116100d35780634ef87786146101cc5780636102495c146101df57806364ddaf19146101f55780636a38d703146102155780637659accb1461022857005b806223de291461010957806301ffc9a71461012e578063150b7a02146101635780632f12313f146101a857005b3661010757005b005b34801561011557600080fd5b50610107610124366004610e4e565b5050505050505050565b34801561013a57600080fd5b5061014e610149366004610ef9565b6103b3565b60405190151581526020015b60405180910390f35b34801561016f57600080fd5b5061018f61017e366004610f2a565b630a85bd0160e11b95945050505050565b6040516001600160e01b0319909116815260200161015a565b3480156101b457600080fd5b506101be60015481565b60405190815260200161015a565b61014e6101da366004610f99565b610405565b3480156101eb57600080fd5b506101be60025481565b34801561020157600080fd5b5061014e610210366004610fe5565b610468565b61014e610223366004610f99565b610531565b61014e61023636600461106c565b610585565b34801561024757600080fd5b5061026f7f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161015a565b34801561029357600080fd5b5061014e6102a2366004610fe5565b6105ec565b3480156102b357600080fd5b5061026f7f000000000000000000000000000000000000000000000000000000000000000081565b3480156102e757600080fd5b5061026f7f000000000000000000000000000000000000000000000000000000000000000081565b34801561031b57600080fd5b5061018f61032a36600461111c565b63bc197c8160e01b98975050505050505050565b34801561034a57600080fd5b506003546101be565b34801561035f57600080fd5b5061010761036e3660046111b6565b6106f0565b61014e6103813660046111d8565b610805565b34801561039257600080fd5b5061018f6103a1366004611265565b63f23a6e6160e01b9695505050505050565b60006001600160e01b03198216630a85bd0160e11b14806103e457506001600160e01b03198216630271189760e51b145b806103ff57506001600160e01b031982166301ffc9a760e01b145b92915050565b60006104118484610868565b6104555760405162461bcd60e51b815260206004820152601060248201526f496e76616c6964207265636f7665727960801b60448201526064015b60405180910390fd5b61045e82600155565b5060019392505050565b60008061048461047f61047a60035490565b610882565b610915565b9050600061049482600254610996565b604051633a94343960e21b81529091506001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063ea50d0e4906104e7908890889086906004016112cb565b602060405180830381865afa158015610504573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105289190611344565b95945050505050565b600061053d8484610868565b61057c5760405162461bcd60e51b815260206004820152601060248201526f496e76616c6964207265636f7665727960801b604482015260640161044c565b61045e82600255565b60006105918989610a73565b6105cf5760405162461bcd60e51b815260206004820152600f60248201526e496e76616c696420706173736b657960881b604482015260640161044c565b6105dd878787878787610ac9565b50600198975050505050505050565b60408051600280825260608201835260009283929190602083019080368337019050509050600154816000815181106106275761062761137c565b60209081029190910101526003545b60001b8160018151811061064c5761064c61137c565b6020908102919091010152604051633a94343960e21b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063ea50d0e4906106a7908790879086906004016112cb565b602060405180830381865afa1580156106c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106e89190611344565b949350505050565b600054610100900460ff16158080156107105750600054600160ff909116105b8061072a5750303b15801561072a575060005460ff166001145b61078d5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161044c565b6000805460ff1916600117905580156107b0576000805461ff0019166101001790555b600183905560028290558015610800576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050565b60006108118787610a73565b61084f5760405162461bcd60e51b815260206004820152600f60248201526e496e76616c696420706173736b657960881b604482015260640161044c565b61085b85858585610c53565b5060019695505050505050565b60008061048461047f61047a600380546001810190915590565b6060600061088f83610c9a565b600101905060008167ffffffffffffffff8111156108af576108af611366565b6040519080825280601f01601f1916602001820160405280156108d9576020820181803683370190505b5090508181016020015b600019016f181899199a1a9b1b9c1cb0b131b232b360811b600a86061a8153600a85049450846108e357509392505050565b6000806040518060400160405280601a81526020017f19457468657265756d205369676e6564204d6573736167653a0a0000000000008152509050600061095c8451610882565b90506000828286604051602001610975939291906113b6565b60408051601f19818403018152919052805160209091012095945050505050565b604080518181526108208101825260609160009190602082016108008036833701905050905060005b6020811015610a10576109e18582602081106109dd576109dd61137c565b1a90565b8282815181106109f3576109f361137c565b602090810291909101015280610a088161140f565b9150506109bf565b5060005b6020811015610a6b57610a328482602081106109dd576109dd61137c565b82610a3e836020611428565b81518110610a4e57610a4e61137c565b602090810291909101015280610a638161140f565b915050610a14565b509392505050565b6040805160028082526060820183526000928392919060208301908036833701905050905060015481600081518110610aae57610aae61137c565b60209081029190910101526003805460018101909155610636565b8481148015610adf5750821580610adf57508281145b610b215760405162461bcd60e51b815260206004820152601360248201527277726f6e67206172726179206c656e6774687360681b604482015260640161044c565b6000839003610bd75760005b85811015610bd157610bbf878783818110610b4a57610b4a61137c565b9050602002016020810190610b5f919061143b565b6000858585818110610b7357610b7361137c565b9050602002810190610b859190611456565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610d7292505050565b80610bc98161140f565b915050610b2d565b50610c4b565b60005b85811015610c4957610c37878783818110610bf757610bf761137c565b9050602002016020810190610c0c919061143b565b868684818110610c1e57610c1e61137c565b90506020020135858585818110610b7357610b7361137c565b80610c418161140f565b915050610bda565b505b505050505050565b610c94848484848080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610d7292505050565b50505050565b60008072184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b8310610cd95772184f03e93ff9f4daa797ed6e38ed64bf6a1f0160401b830492506040015b6d04ee2d6d415b85acef81000000008310610d05576d04ee2d6d415b85acef8100000000830492506020015b662386f26fc100008310610d2357662386f26fc10000830492506010015b6305f5e1008310610d3b576305f5e100830492506008015b6127108310610d4f57612710830492506004015b60648310610d61576064830492506002015b600a83106103ff5760010192915050565b600080846001600160a01b03168484604051610d8e919061149d565b60006040518083038185875af1925050503d8060008114610dcb576040519150601f19603f3d011682016040523d82523d6000602084013e610dd0565b606091505b509150915081610de257805160208201fd5b5050505050565b80356001600160a01b0381168114610e0057600080fd5b919050565b60008083601f840112610e1757600080fd5b50813567ffffffffffffffff811115610e2f57600080fd5b602083019150836020828501011115610e4757600080fd5b9250929050565b60008060008060008060008060c0898b031215610e6a57600080fd5b610e7389610de9565b9750610e8160208a01610de9565b9650610e8f60408a01610de9565b955060608901359450608089013567ffffffffffffffff80821115610eb357600080fd5b610ebf8c838d01610e05565b909650945060a08b0135915080821115610ed857600080fd5b50610ee58b828c01610e05565b999c989b5096995094979396929594505050565b600060208284031215610f0b57600080fd5b81356001600160e01b031981168114610f2357600080fd5b9392505050565b600080600080600060808688031215610f4257600080fd5b610f4b86610de9565b9450610f5960208701610de9565b935060408601359250606086013567ffffffffffffffff811115610f7c57600080fd5b610f8888828901610e05565b969995985093965092949392505050565b600080600060408486031215610fae57600080fd5b833567ffffffffffffffff811115610fc557600080fd5b610fd186828701610e05565b909790965060209590950135949350505050565b60008060208385031215610ff857600080fd5b823567ffffffffffffffff81111561100f57600080fd5b61101b85828601610e05565b90969095509350505050565b60008083601f84011261103957600080fd5b50813567ffffffffffffffff81111561105157600080fd5b6020830191508360208260051b8501011115610e4757600080fd5b6000806000806000806000806080898b03121561108857600080fd5b883567ffffffffffffffff808211156110a057600080fd5b6110ac8c838d01610e05565b909a50985060208b01359150808211156110c557600080fd5b6110d18c838d01611027565b909850965060408b01359150808211156110ea57600080fd5b6110f68c838d01611027565b909650945060608b013591508082111561110f57600080fd5b50610ee58b828c01611027565b60008060008060008060008060a0898b03121561113857600080fd5b61114189610de9565b975061114f60208a01610de9565b9650604089013567ffffffffffffffff8082111561116c57600080fd5b6111788c838d01611027565b909850965060608b013591508082111561119157600080fd5b61119d8c838d01611027565b909650945060808b0135915080821115610ed857600080fd5b600080604083850312156111c957600080fd5b50508035926020909101359150565b600080600080600080608087890312156111f157600080fd5b863567ffffffffffffffff8082111561120957600080fd5b6112158a838b01610e05565b909850965086915061122960208a01610de9565b955060408901359450606089013591508082111561124657600080fd5b5061125389828a01610e05565b979a9699509497509295939492505050565b60008060008060008060a0878903121561127e57600080fd5b61128787610de9565b955061129560208801610de9565b94506040870135935060608701359250608087013567ffffffffffffffff8111156112bf57600080fd5b61125389828a01610e05565b60408152826040820152828460608301376000606084830101526000601f19601f8501168201606081016020606085840301818601528186518084526080850191508288019450600093505b808410156113375784518252938201936001939093019290820190611317565b5098975050505050505050565b60006020828403121561135657600080fd5b81518015158114610f2357600080fd5b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b60005b838110156113ad578181015183820152602001611395565b50506000910152565b600084516113c8818460208901611392565b8451908301906113dc818360208901611392565b84519101906113ef818360208801611392565b0195945050505050565b634e487b7160e01b600052601160045260246000fd5b600060018201611421576114216113f9565b5060010190565b808201808211156103ff576103ff6113f9565b60006020828403121561144d57600080fd5b610f2382610de9565b6000808335601e1984360301811261146d57600080fd5b83018035915067ffffffffffffffff82111561148857600080fd5b602001915036819003821315610e4757600080fd5b600082516114af818460208701611392565b919091019291505056fea2646970667358221220b1bf42ec74893655a5120436941dec201375eeff3a0978ecff937c61ed52672d64736f6c63430008110033",
  "deployedBytecode": "0x60806040523480156200001157600080fd5b5060043610620000ab5760003560e01c80639ceac563116200006e5780639ceac5631462000162578063becd18aa14620001a0578063d9e374ef14620001b7578063dc55776f146200021a578063f936d15b146200023157600080fd5b80631a095c6014620000b057806347f7d84d14620000dc578063572b6c0514620000f35780636ff56aa4146200010a57806395083b73146200014b575b600080fd5b620000c7620000c136600462000ac5565b62000248565b60405190151581526020015b60405180910390f35b620000c7620000ed36600462000bcb565b62000337565b620000c76200010436600462000cc6565b62000423565b620001327f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b039091168152602001620000d3565b620000c76200015c36600462000ce4565b62000455565b620001796200017336600462000d5b565b62000532565b6040805182516001600160a01b0316815260209283015115159281019290925201620000d3565b620000c7620001b136600462000ce4565b62000597565b620001fa620001c836600462000d5b565b80516020818301810180516000825292820191909301209152546001600160a01b03811690600160a01b900460ff1682565b604080516001600160a01b039093168352901515602083015201620000d3565b620001326200022b36600462000d94565b62000623565b620001326200024236600462000dc1565b62000706565b6000620002553362000423565b6200027d5760405162461bcd60e51b8152600401620002749062000e19565b60405180910390fd5b87620002898162000870565b6000808a6040516200029c919062000e88565b9081526040519081900360200181205463775a5d7f60e11b82526001600160a01b03169150819063eeb4bafe90620002e3908c908c908c908c908c908c9060040162000ecf565b6020604051808303816000875af115801562000303573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000329919062000f1d565b9a9950505050505050505050565b6000620003443362000423565b620003635760405162461bcd60e51b8152600401620002749062000e19565b896200036f8162000870565b6000808c60405162000382919062000e88565b90815260405190819003602001812054637659accb60e01b82526001600160a01b031691508190637659accb90620003cd908e908e908e908e908e908e908e908e9060040162000fda565b6020604051808303816000875af1158015620003ed573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000413919062000f1d565b9c9b505050505050505050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0390811691161490565b6000620004623362000423565b620004815760405162461bcd60e51b8152600401620002749062000e19565b846200048d8162000870565b60008087604051620004a0919062000e88565b9081526040519081900360200181205463277c3bc360e11b82526001600160a01b031691508190634ef8778690620004e19089908990899060040162001080565b6020604051808303816000875af115801562000501573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019062000527919062000f1d565b979650505050505050565b60408051808201909152600080825260208201526000808360405162000559919062000e88565b90815260408051918290036020908101832083830190925290546001600160a01b038116835260ff600160a01b909104161515908201529392505050565b6000620005a43362000423565b620005c35760405162461bcd60e51b8152600401620002749062000e19565b84620005cf8162000870565b60008087604051620005e2919062000e88565b90815260405190819003602001812054636a38d70360e01b82526001600160a01b031691508190636a38d70390620004e19089908990899060040162001080565b6000620006fe8260001b604051806020016200063f90620009a3565b601f1982820381018352601f90910116604081905260248101889052604481018790527f00000000000000000000000000000000000000000000000000000000000000009060640160408051601f19818403018152918152602080830180516001600160e01b03166337b709c360e21b1790529051620006c293929101620010a6565b60408051601f1981840301815290829052620006e29291602001620010ea565b60405160208183030381529060405280519060200120620008ee565b949350505050565b6000808560405162000719919062000e88565b9081526040519081900360200190205460ff600160a01b90910416156200078f5760405162461bcd60e51b815260206004820152602360248201527f43656c65737469616c3a2043656c65737469616c20616c72656164792065786960448201526273747360e81b606482015260840162000274565b60006200079e85858562000623565b90506001600160a01b0381163b8015620007bb57509050620006fe565b604051602481018790526044810186905284907f00000000000000000000000000000000000000000000000000000000000000009060640160408051601f198184030181529181526020820180516001600160e01b03166337b709c360e21b179052516200082990620009a3565b62000836929190620010a6565b8190604051809103906000f590508015801562000857573d6000803e3d6000fd5b50925062000866878462000904565b5050949350505050565b60008160405162000882919062000e88565b9081526040519081900360200190205460ff600160a01b90910416620008eb5760405162461bcd60e51b815260206004820152601c60248201527f43656c65737469616c3a20496e76616c69642043656c65737469616c00000000604482015260640162000274565b50565b6000620008fd83833062000979565b9392505050565b6040805180820182526001600160a01b03831681526001602082015290516000906200093290859062000e88565b908152604051602091819003820190208251815493909201516001600160a01b039092166001600160a81b031990931692909217600160a01b911515919091021790555050565b6000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b610727806200111e83390190565b634e487b7160e01b600052604160045260246000fd5b600082601f830112620009d957600080fd5b813567ffffffffffffffff80821115620009f757620009f7620009b1565b604051601f8301601f19908116603f0116810190828211818310171562000a225762000a22620009b1565b8160405283815286602085880101111562000a3c57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008083601f84011262000a6f57600080fd5b50813567ffffffffffffffff81111562000a8857600080fd5b60208301915083602082850101111562000aa157600080fd5b9250929050565b80356001600160a01b038116811462000ac057600080fd5b919050565b600080600080600080600060a0888a03121562000ae157600080fd5b873567ffffffffffffffff8082111562000afa57600080fd5b62000b088b838c01620009c7565b985060208a013591508082111562000b1f57600080fd5b62000b2d8b838c0162000a5c565b909850965086915062000b4360408b0162000aa8565b955060608a0135945060808a013591508082111562000b6157600080fd5b5062000b708a828b0162000a5c565b989b979a50959850939692959293505050565b60008083601f84011262000b9657600080fd5b50813567ffffffffffffffff81111562000baf57600080fd5b6020830191508360208260051b850101111562000aa157600080fd5b600080600080600080600080600060a08a8c03121562000bea57600080fd5b893567ffffffffffffffff8082111562000c0357600080fd5b62000c118d838e01620009c7565b9a5060208c013591508082111562000c2857600080fd5b62000c368d838e0162000a5c565b909a50985060408c013591508082111562000c5057600080fd5b62000c5e8d838e0162000b83565b909850965060608c013591508082111562000c7857600080fd5b62000c868d838e0162000b83565b909650945060808c013591508082111562000ca057600080fd5b5062000caf8c828d0162000b83565b915080935050809150509295985092959850929598565b60006020828403121562000cd957600080fd5b620008fd8262000aa8565b6000806000806060858703121562000cfb57600080fd5b843567ffffffffffffffff8082111562000d1457600080fd5b62000d2288838901620009c7565b9550602087013591508082111562000d3957600080fd5b5062000d488782880162000a5c565b9598909750949560400135949350505050565b60006020828403121562000d6e57600080fd5b813567ffffffffffffffff81111562000d8657600080fd5b620006fe84828501620009c7565b60008060006060848603121562000daa57600080fd5b505081359360208301359350604090920135919050565b6000806000806080858703121562000dd857600080fd5b843567ffffffffffffffff81111562000df057600080fd5b62000dfe87828801620009c7565b97602087013597506040870135966060013595509350505050565b60208082526029908201527f56555a493a2063616c6c6572206973206e6f74207468652074727573746564206040820152683337b93bb0b93232b960b91b606082015260800190565b60005b8381101562000e7f57818101518382015260200162000e65565b50506000910152565b6000825162000e9c81846020870162000e62565b9190910192915050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b60808152600062000ee560808301888a62000ea6565b6001600160a01b038716602084015260408301869052828103606084015262000f1081858762000ea6565b9998505050505050505050565b60006020828403121562000f3057600080fd5b81518015158114620008fd57600080fd5b81835260006020808501808196508560051b810191508460005b8781101562000fcd5782840389528135601e1988360301811262000f7e57600080fd5b8701858101903567ffffffffffffffff81111562000f9b57600080fd5b80360382131562000fab57600080fd5b62000fb886828462000ea6565b9a87019a955050509084019060010162000f5b565b5091979650505050505050565b60808152600062000ff0608083018a8c62000ea6565b8281036020848101919091528882528991810160005b8a81101562001036576001600160a01b03620010228562000aa8565b168252928201929082019060010162001006565b5084810360408601528781526001600160fb1b038811156200105757600080fd5b8760051b9250828983830137909101838103820160608501529062000413818301868862000f41565b6040815260006200109660408301858762000ea6565b9050826020830152949350505050565b60018060a01b03831681526040602082015260008251806040840152620010d581606085016020870162000e62565b601f01601f1916919091016060019392505050565b60008351620010fe81846020880162000e62565b8351908301906200111481836020880162000e62565b0194935050505056fe608060405260405161072738038061072783398101604081905261002291610319565b61002e82826000610035565b5050610436565b61003e8361006b565b60008251118061004b5750805b156100665761006483836100ab60201b6100291760201c565b505b505050565b610074816100d7565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606100d08383604051806060016040528060278152602001610700602791396101a9565b9392505050565b6100ea8161022260201b6100551760201c565b6101515760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201526c1bdd08184818dbdb9d1c9858dd609a1b60648201526084015b60405180910390fd5b806101887f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc60001b61023160201b6100641760201c565b80546001600160a01b0319166001600160a01b039290921691909117905550565b6060600080856001600160a01b0316856040516101c691906103e7565b600060405180830381855af49150503d8060008114610201576040519150601f19603f3d011682016040523d82523d6000602084013e610206565b606091505b50909250905061021886838387610234565b9695505050505050565b6001600160a01b03163b151590565b90565b606083156102a357825160000361029c576001600160a01b0385163b61029c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610148565b50816102ad565b6102ad83836102b5565b949350505050565b8151156102c55781518083602001fd5b8060405162461bcd60e51b81526004016101489190610403565b634e487b7160e01b600052604160045260246000fd5b60005b838110156103105781810151838201526020016102f8565b50506000910152565b6000806040838503121561032c57600080fd5b82516001600160a01b038116811461034357600080fd5b60208401519092506001600160401b038082111561036057600080fd5b818501915085601f83011261037457600080fd5b815181811115610386576103866102df565b604051601f8201601f19908116603f011681019083821181831017156103ae576103ae6102df565b816040528281528860208487010111156103c757600080fd5b6103d88360208301602088016102f5565b80955050505050509250929050565b600082516103f98184602087016102f5565b9190910192915050565b60208152600082518060208401526104228160408501602087016102f5565b601f01601f19169190910160400192915050565b6102bb806104456000396000f3fe60806040523661001357610011610017565b005b6100115b610027610022610067565b61009f565b565b606061004e838360405180606001604052806027815260200161025f602791396100c3565b9392505050565b6001600160a01b03163b151590565b90565b600061009a7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b905090565b3660008037600080366000845af43d6000803e8080156100be573d6000f35b3d6000fd5b6060600080856001600160a01b0316856040516100e0919061020f565b600060405180830381855af49150503d806000811461011b576040519150601f19603f3d011682016040523d82523d6000602084013e610120565b606091505b50915091506101318683838761013b565b9695505050505050565b606083156101af5782516000036101a8576001600160a01b0385163b6101a85760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064015b60405180910390fd5b50816101b9565b6101b983836101c1565b949350505050565b8151156101d15781518083602001fd5b8060405162461bcd60e51b815260040161019f919061022b565b60005b838110156102065781810151838201526020016101ee565b50506000910152565b600082516102218184602087016101eb565b9190910192915050565b602081526000825180602084015261024a8160408501602087016101eb565b601f01601f1916919091016040019291505056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a2646970667358221220df5e088a16650cdc3010db20ecd1e2b26729605480c947e2f8d77aac24e8ff8464736f6c63430008110033416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212203f2470c04963f6dc3f34f4b7ba69c482496dd15cf524094cb9d7834fa935ff9464736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3430,
        "contract": "contracts/CelestialFactory.sol:CelestialFactory",
        "label": "CelestialNameToDetails",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_string_memory_ptr,t_struct(CelestialDetails)3425_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_string_memory_ptr,t_struct(CelestialDetails)3425_storage)": {
        "encoding": "mapping",
        "key": "t_string_memory_ptr",
        "label": "mapping(string => struct CelestialStorage.CelestialDetails)",
        "numberOfBytes": "32",
        "value": "t_struct(CelestialDetails)3425_storage"
      },
      "t_string_memory_ptr": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(CelestialDetails)3425_storage": {
        "encoding": "inplace",
        "label": "struct CelestialStorage.CelestialDetails",
        "members": [
          {
            "astId": 3422,
            "contract": "contracts/CelestialFactory.sol:CelestialFactory",
            "label": "walletAddress",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 3424,
            "contract": "contracts/CelestialFactory.sol:CelestialFactory",
            "label": "isUsed",
            "offset": 20,
            "slot": "0",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "32"
      }
    }
  }
}